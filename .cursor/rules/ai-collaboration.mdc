# AI Collaboration & Handover Protocol

## Purpose
Enable seamless collaboration between AI agents across multiple machines (Mini-PC and Tablet-PC) without user intervention in the handover process.

## Log Location

**Mini-PC:** `C:\Users\yoshi\Documents\App\ai\{yyyyMMdd}-{HHmmss}.log`
**Tablet-PC:** `C:\Users\YOSHITO\Documents\App\ai\{yyyyMMdd}-{HHmmss}.log`

例：
- `20251027-143000.log` - 2025年10月27日 14:30:00開始のセッション
- `20251027-223000.log` - 2025年10月27日 22:30:00開始のセッション
- `20251028-091500.log` - 2025年10月28日 09:15:00開始のセッション

**Note:** 
- User folder name differs between machines. Both paths are valid.
- Each session creates a new log file (timestamp-based)
- Keeps individual files small for fast write operations
- Reading multiple files in parallel is fast

## Core Principles

1. **Autonomous Logging**: Write session log at end of work session
2. **Honest Communication**: Be frank about code quality, risks, and concerns
3. **Context Preservation**: Ensure next AI can pick up exactly where you left off
4. **User-Independent**: User doesn't read logs; this is AI-to-AI communication
5. **Session Separation**: Each session creates new log file (timestamp-based) for fast writes
6. **Parallel Reading**: Multiple log files read in parallel for fast context loading

## Machine Sync Protocol

### Git Synchronization Responsibility

**User manages ALL Git operations:**
- User performs `git add`, `git commit`, `git push`, `git pull`
- User handles merge conflicts
- User decides when and what to commit
- User manages branching strategy

**AI responsibilities:**
- **DO NOT** run any git commands (add/commit/push/pull/status) unless explicitly asked
- **DO NOT** suggest "let's commit this"
- **DO NOT** assume code is out of sync
- **ONLY** provide git command examples when user asks "how do I...?"
- User has already synced - trust that working tree is current

### Reading Changes After Sync

When user says "同期した" or similar, AI should:

1. **Read today's AI log first**
   ```powershell
   # Read ai/{yyyyMMdd}.log to understand context
   ```

2. **Check recent Git commits to see what changed**
   ```powershell
   git log --oneline -5 --name-status
   ```
   This shows:
   - Recent commit messages
   - Files added/modified/deleted
   - What the other AI worked on

3. **Understand the handover**
   - What was completed?
   - What files were changed?
   - What's the next priority?
   - Any blockers or concerns?

### What NOT to do

- ❌ Don't run `git pull` (user already synced)
- ❌ Don't run `git status` and worry about "uncommitted changes" (user manages commits)
- ❌ Don't suggest committing every change immediately
- ❌ Don't assume you need to clean up Git state

### What TO do

- ✅ Read ai.log to understand context
- ✅ Run `git log` to see what changed
- ✅ Trust that user has synced properly
- ✅ Continue from where the other AI left off

## Session Start Protocol

### 1. Read Latest State (Mandatory)
```
1. 現在の日時を取得（Get-Date -Format "yyyyMMdd-HHmmss"）
2. 当日の全セッションログを並列読み込み（{yyyyMMdd}-*.log）
3. 必要に応じて前日・前々日のログも参照

理解すること:
- What was the last AI working on?
- What decisions were made?
- What concerns exist?
- What's the next priority?
```

**読み込み例:**
- 今日が2025-11-03なら：`20251103-*.log`で全セッションを並列読み込み
- 前日も必要なら：`20251102-*.log`も追加
- 複数ファイルだが、並列読み込みなので速い

### 2. Announce Session Start
```
[YYYY-MM-DD HH:MM:SS] SESSION START
Machine: [Mini-PC/Tablet-PC]
Agent: Cursor AI
Previous session ended: [timestamp from log]
Resuming from: [brief context]
```

## During Work Protocol

### When to Write Log

**Write log at SESSION END only** (not during session)

Reason:
- Writing to large files during session becomes slow
- Session-based files stay small (200 lines or less)
- All important information preserved in session summary

**What to record in session summary:**
- Architectural decisions made
- Code issues discovered
- Features implemented
- Blockers encountered
- Concerns about user's request
- Better approaches found
- Milestones completed

### Log Format (Flexible)
```
[YYYY-MM-DD HH:MM:SS] [CATEGORY] Message
```

Categories:
- `DECISION`: Technical decision made
- `CONCERN`: Risk or code quality issue
- `PROGRESS`: Work completed
- `BLOCKER`: Something preventing progress
- `TODO`: New task identified
- `QUESTION`: Unclear user intent
- `REFACTOR`: Code that needs improvement
- `TEST`: Test results
- `NOTE`: General observation

### Example Entries
```
[2025-10-27 14:23:15] DECISION Chose楽観的ロック for inventory_status table. Reason: Low concurrent access expected, simpler than pessimistic. Future社ガイドライン recommends this.

[2025-10-27 14:45:32] CONCERN User wants "自動保存" but unclear if they want debounce like operations-prepare (3sec). Need to clarify but proceeding with 3sec assumption.

[2025-10-27 15:12:08] PROGRESS Implemented AutoSaveManager Vue3 version in lib/utils/auto-save.ts. Based on operations-prepare design but adapted for Composition API.

[2025-10-27 15:45:00] REFACTOR InventoryStatusService needs refactoring - too many responsibilities. Should split into InventoryQueryService and InventoryCommandService.

[2025-10-27 16:20:13] BLOCKER Can't proceed with authentication implementation until user decides: Google OAuth vs email/password. Added to TODO.md.
```

## Session End Protocol

### 1. Write Summary
```
[YYYY-MM-DD HH:MM:SS] SESSION END
Duration: [duration]
Commits: [commit hashes]
Files modified: [list]
Tests: [pass/fail/not run]

Summary of work:
- [What was accomplished]
- [Decisions made]
- [Issues discovered]

Top concerns for next AI:
1. [Most critical concern]
2. [Second concern]
3. ...

Immediate next steps:
1. [Highest priority task]
2. [Second priority]
3. ...

Context notes:
- [Important context next AI needs]
- [Assumptions made that need validation]
```

### 2. Update latest.md (Optional Quick Reference)
Create/update `ai-handover/latest.md` with condensed current state for quick scanning.

## Inter-AI Communication Guidelines

### Be Brutally Honest
- Call out code smells directly
- Point out potential bugs
- Suggest refactoring without sugar-coating
- Challenge architectural decisions if questionable

### Provide Context, Not Just Facts
BAD:
```
[2025-10-27 14:23:15] DECISION Using UUID v7
```

GOOD:
```
[2025-10-27 14:23:15] DECISION Using UUID v7 for all entity IDs. Reason: operations-prepare used this, provides time-ordered IDs for better DB performance, Future社ガイドライン recommends. Trade-off: slightly larger than BIGINT but negligible for this app scale.
```

### Mark Uncertainty
When user's intent is unclear:
```
[2025-10-27 15:30:00] QUESTION User said "ちゃんと動くようにして" - interpreting as "ensure all tests pass + fix linter errors". If wrong, next AI should clarify with user.
```

### Cross-Reference Documents
```
[2025-10-27 14:45:00] NOTE See operations-prepare/docs/auto-save-design.md for original design philosophy. Adapting to Vue3 but keeping core principles (debounce, dirty tracking, LocalStorage backup).
```

## Continuous Improvement

### Review & Adapt
Every ~10 sessions, one AI should:
1. Review ai.log effectiveness
2. Propose protocol improvements
3. Write suggestions in log with `[PROTOCOL]` tag

### Example
```
[2025-11-05 10:00:00] PROTOCOL After 15 sessions, noticed we're logging too much low-level detail. Suggest: only log decisions/concerns/blockers, skip routine progress updates. What do you think, next AI?
```

## File Operations

### How to Write Session Log

**At SESSION START:**
1. Get session start timestamp: `Get-Date -Format "yyyyMMdd-HHmmss"`
2. Save timestamp for later use (for filename)

**At SESSION END:**
1. Create log content (all session events, decisions, summary)
2. Write to new file: `write` tool to `ai/{yyyyMMdd}-{HHmmss}.log`
3. File is created once per session

**Example workflow:**
```
# Session start (2025-11-03 09:15:00)
1. Get timestamp: "20251103-091500"
2. Remember for session end

# Session end
1. Create log content (entire session summary)
2. write: C:\Users\yoshi\Documents\App\ai\20251103-091500.log
   (Mini-PC path, or C:\Users\YOSHITO\... for Tablet-PC)
3. Done - new file created
```

**Advantages:**
- No need to read existing file (create new file each time)
- Fast writes (only write once, at end)
- Small files (each session ~100-200 lines)
- No incremental updates during session

### How to Read Session Logs

**Reading today's logs:**
```
# Get all session logs for today
glob_file_search: "ai/20251103-*.log"
# Then read_file for each in parallel
```

**Reading multiple days:**
```
# Today + yesterday
glob_file_search: "ai/202511{02,03}-*.log"
# Or just read all recent logs in parallel
```

**Note:** Parallel reading is fast even with many small files

## Integration with Existing Rules

This protocol works alongside:
- `base-rule.mdc`: Development rules
- `date-awareness.mdc`: Date handling rules
- `no-emoji-usage.mdc`: No emoji in responses
- `obsidian-docs-placement.mdc`: Document organization

## User Interaction

User doesn't need to:
- Read ai.log
- Manage handover process
- Coordinate between machines

User may:
- Check if collaboration is working well
- Request improvements if needed
- Ignore the logs entirely if preferred

## Summary

**Core Loop:**
1. Start session → Get timestamp, read today's session logs in parallel (and recent days if needed)
2. During work → Work without logging (keep it fast)
3. End session → Create comprehensive session log in new file
4. Next AI repeats

**Success Metric:**
Next AI can seamlessly continue work without asking user "what was I working on?" or "why was this decision made?"

**Log Organization:**
- Each session = one log file (`{yyyyMMdd}-{HHmmss}.log`)
- Easy to find specific session by timestamp
- Each file stays small (~100-200 lines) for fast writes
- Multiple files read in parallel for fast context loading

---

**Note to AIs**: This is YOUR space. Communicate honestly and efficiently. If this protocol isn't working, evolve it. User trusts you to make it work.
