<!DOCTYPE html>
<html>

<head>
  <base target="_top">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #09090b;
      color: #fafafa;
      font-family: ui-sans-serif, system-ui, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .help-text {
      font-size: 10px;
      color: #71717a;
      font-family: ui-monospace, monospace;
      margin-top: 4px;
      text-transform: uppercase;
    }

    .cell-selected {
      outline: 2px solid #3b82f6;
      outline-offset: -2px;
      background-color: #18181b;
      color: white !important;
    }

    .editing-input {
      background: #27272a;
      border: none;
      color: white;
      width: 100%;
      outline: none;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 14px;
    }

    /* 追加: ジャンプ用入力欄のスタイル */
    #jump-input {
      background: #18181b;
      border: 1px solid #3f3f46;
      color: white;
      outline: none;
      padding: 4px 12px;
      border-radius: 6px;
      font-family: ui-monospace, monospace;
      font-size: 12px;
      width: 140px;
      text-align: center;
      transition: all 0.2s;
    }

    #jump-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }

    ::-webkit-scrollbar {
      width: 4px;
    }

    ::-webkit-scrollbar-thumb {
      background: #3f3f46;
      border-radius: 10px;
    }

    #board {
      flex: 1;
      min-height: 0;
    }

    .btn-action {
      transition: all 0.2s;
      cursor: pointer;
    }

    .btn-action:hover {
      background-color: #27272a;
      color: white;
    }
  </style>
</head>

<body class="p-6">
  <div class="flex justify-between items-end mb-6 border-b border-zinc-800 pb-4 shrink-0 relative">
    <div>
      <h1 class="text-xl font-bold tracking-tighter text-white">GCal KeyBoard Edit</h1>
      <p class="help-text">Arrow: NAV/ADJUST | Tab: MOVE | C:CREATE | D:DELETE | R:REFRESH | T:NOW</p>
      <p class="help-text text-zinc-500">[:PREV | ]:NEXT | G:JUMP | Alt+T:TODAY</p>
    </div>

    <div class="absolute left-1/2 bottom-4 -translate-x-1/2 z-50">
      <input id="jump-input" type="text" placeholder="YYYY/MM/DD" tabindex="-1">
    </div>

    <div class="flex items-center gap-2">
      <a href="https://script.google.com/u/0/home/projects/1wC7aXLi_rVdvxAiXm09W0WRLFynPPHTA0QJyRJSZl6RRaMpD_s_PdAd4/edit"
        target="_blank"
        class="btn-action text-[10px] font-mono text-zinc-400 bg-zinc-900 px-3 py-1 rounded border border-zinc-800 flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path
            d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
        </svg>
        EDIT CODE
      </a>

      <button onclick="refresh()"
        class="btn-action text-[10px] font-mono text-zinc-400 bg-zinc-900 px-3 py-1 rounded border border-zinc-800">REFRESH
        (R)</button>
      <div id="status" class="text-[10px] font-mono text-zinc-600 bg-zinc-950 px-2 py-1 rounded border border-zinc-900">
        READY</div>
    </div>
  </div>

  <div id="loading" class="text-zinc-500 text-center py-20 font-mono text-sm animate-pulse">CONNECTING_TO_CALENDAR...
  </div>
  <div id="board" class="grid grid-cols-3 gap-4 h-full overflow-hidden"></div>

  <script>
    let columns = [];
    let activeCol = 1; let activeRow = 0; let activeCell = 0;
    let isEditing = false;
    let undoStack = null;
    let debounceTimers = {};
    const STEP = 15;

    // 追加: 基準日変数
    let currentBaseDate = new Date();

    function refresh() {
      setStatus('REFRESHING...');
      document.getElementById('board').style.opacity = '0.5';

      // 修正: 引数に日付を渡す
      google.script.run.withSuccessHandler(data => {
        columns = data.map(col => ({
          ...col,
          items: col.items.map(item => ({ ...item, start: new Date(item.start), end: new Date(item.end) }))
        }));
        document.getElementById('loading').style.display = 'none';
        document.getElementById('board').style.opacity = '1';

        // 基準日(中央カラム)を選択し、可能な限りカーソル位置を維持
        if (columns[1]) {
          activeCol = 1;
          activeRow = Math.min(activeRow, Math.max(0, columns[1].items.length - 1));
          if (activeRow < 0) activeRow = 0;
        }

        updateJumpInputDisplay(); // インプット欄更新
        render();
        setStatus('READY');
      }).getEvents(currentBaseDate.toISOString());
    }

    // 追加: インプット欄の日付更新
    function updateJumpInputDisplay() {
      const d = currentBaseDate;
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      const el = document.getElementById('jump-input');
      if (el) el.value = `${y}/${m}/${day}`;
    }

    function render() {
      const board = document.getElementById('board');
      board.innerHTML = '';
      columns.forEach((col, cIdx) => {
        const dateObj = new Date(col.date);
        const dateStr = dateObj.toLocaleDateString('ja-JP', { weekday: 'short', day: 'numeric' });
        const colDiv = document.createElement('div');
        colDiv.className = `flex flex-col border border-zinc-800 rounded-2xl p-4 bg-zinc-900/20 h-full overflow-hidden ${cIdx === activeCol ? 'ring-1 ring-zinc-700 bg-zinc-900/40' : 'opacity-40'}`;
        colDiv.innerHTML = `<h2 class="text-[10px] font-black text-zinc-500 mb-4 uppercase tracking-widest shrink-0">${dateStr}</h2>`;

        const scrollArea = document.createElement('div');
        scrollArea.className = "space-y-2 overflow-y-auto flex-1 pr-1";

        col.items.forEach((item, rIdx) => {
          const isSelected = (cIdx === activeCol && rIdx === activeRow);
          const itemDiv = document.createElement('div');
          itemDiv.className = `border border-zinc-800 rounded-xl bg-zinc-950 p-3 transition-all ${isSelected ? 'border-zinc-500 shadow-lg shadow-black' : ''}`;

          const tCls = (isSelected && activeCell === 0) ? 'cell-selected' : '';
          const sCls = (isSelected && activeCell === 1) ? 'cell-selected' : 'text-zinc-200';
          const eCls = (isSelected && activeCell === 2) ? 'cell-selected' : 'text-zinc-200';

          itemDiv.innerHTML = `
            <div class="flex items-center justify-between gap-2">
              <div id="item-${cIdx}-${rIdx}-title" class="px-2 py-1 rounded truncate font-semibold text-zinc-200 flex-1 ${tCls}">${item.title || '(Untitled)'}</div>
              <div class="flex items-center gap-1 text-[13px] font-mono shrink-0">
                <div id="item-${cIdx}-${rIdx}-start" class="px-1.5 py-0.5 rounded ${sCls}">${formatDateTime(item.start)}</div>
                <span class="opacity-20 text-zinc-300">→</span>
                <div id="item-${cIdx}-${rIdx}-end" class="px-1.5 py-0.5 rounded ${eCls}">${formatDateTime(item.end)}</div>
              </div>
            </div>
          `;
          scrollArea.appendChild(itemDiv);

          // 修正：スクロール位置の制御を安定化
          if (isSelected) {
            // instantにすることでガタつきを抑止
            setTimeout(() => {
              itemDiv.scrollIntoView({ behavior: 'instant', block: 'nearest' });
            }, 0);
          }
        });
        colDiv.appendChild(scrollArea);
        board.appendChild(colDiv);
      });
    }

    function formatDateTime(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, '0');
      const d = String(date.getDate()).padStart(2, '0');
      const hh = String(date.getHours()).padStart(2, '0');
      const mm = String(date.getMinutes()).padStart(2, '0');
      return `${y}/${m}/${d} ${hh}:${mm}`;
    }

    function moveTab(dir) {
      activeCell += dir;
      const col = columns[activeCol];
      if (activeCell > 2) {
        if (activeRow < col.items.length - 1) { activeRow++; activeCell = 0; }
        else if (activeCol < 2) { activeCol++; activeRow = 0; activeCell = 0; }
        else { activeCell = 2; }
      } else if (activeCell < 0) {
        if (activeRow > 0) { activeRow--; activeCell = 2; }
        else if (activeCol > 0) { activeCol--; activeRow = Math.max(0, columns[activeCol].items.length - 1); activeCell = 2; }
        else { activeCell = 0; }
      }
      render();
    }

    // 追加: ジャンプ用入力欄のイベント設定
    const jumpInput = document.getElementById('jump-input');
    jumpInput.addEventListener('keydown', (e) => {
      e.stopPropagation();
      if (e.key === 'Enter') {
        const val = jumpInput.value;
        if (val) {
          try {
            const d = new Date(val);
            if (!isNaN(d.getTime())) {
              if (d.getFullYear() < 2000) d.setFullYear(new Date().getFullYear());
              currentBaseDate = d;
              refresh();
            }
          } catch (err) { console.error(err); }
        }
        jumpInput.blur();
        document.body.focus();
      }
      if (e.key === 'Escape') {
        updateJumpInputDisplay(); // 元に戻す
        jumpInput.blur();
        document.body.focus();
      }
    });

    // 修正：Tabキーのデフォルト動作を強力に阻止
    window.addEventListener('keydown', (e) => {
      // 編集中の場合はTab入力を許可（または別途制御）
      if (isEditing) return;
      // ジャンプ入力中は無視
      if (document.activeElement === jumpInput) return;

      if (e.key === 'Tab') {
        e.preventDefault(); // これによりバナーへのフォーカス移動を阻止
        moveTab(e.shiftKey ? -1 : 1);
        return;
      }

      if (columns.length === 0) return;
      const col = columns[activeCol];
      const item = col.items[activeRow];

      if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); return; }

      switch (e.key) {
        case 'r': refresh(); break;

        // --- 追加: 日付操作 ---
        case '[':
          currentBaseDate.setDate(currentBaseDate.getDate() - 1);
          refresh();
          break;
        case ']':
          currentBaseDate.setDate(currentBaseDate.getDate() + 1);
          refresh();
          break;
        case 'G': case 'g':
          e.preventDefault();
          jumpInput.focus();
          jumpInput.select();
          break;
        // ---------------------

        case 'ArrowRight':
          activeCol = Math.min(2, activeCol + 1);
          activeRow = Math.min(activeRow, Math.max(0, columns[activeCol].items.length - 1));
          render(); break;
        case 'ArrowLeft':
          activeCol = Math.max(0, activeCol - 1);
          activeRow = Math.min(activeRow, Math.max(0, columns[activeCol].items.length - 1));
          render(); break;
        case 'ArrowDown':
          e.preventDefault();
          if (activeCell === 0) { activeRow = Math.min(col.items.length - 1, activeRow + 1); render(); }
          else if (item) adjust(item, 1);
          break;
        case 'ArrowUp':
          e.preventDefault();
          if (activeCell === 0) { activeRow = Math.max(0, activeRow - 1); render(); }
          else if (item) adjust(item, -1);
          break;
        case 'j': if (item) adjust(item, 1); break;
        case 'k': if (item) adjust(item, -1); break;
        case 't':
          // 変更: Alt+Tで今日、T単体で現在時刻
          if (e.altKey) {
            e.preventDefault();
            currentBaseDate = new Date();
            refresh();
          } else if (item && (activeCell === 1 || activeCell === 2)) {
            const now = getRoundedNow();
            if (activeCell === 1) item.start = now;
            else item.end = now;
            render();
            save(item);
          }
          break;
        case 'i': if (item) { e.preventDefault(); startEdit(item); } break;
        case 'c': case 'n': e.preventDefault(); create(); break;
        case 'd': del(); break;
        case 'Enter':
          if (item) { e.preventDefault(); startEdit(item); }
          break;
      }
    }, true); // trueにしてキャプチャリングフェーズで捕捉

    /**
     * 編集を開始する
     * activeCellに応じて タイトル / 開始時間 / 終了時間 を編集
     */
    function startEdit(item) {
      isEditing = true;
      let elId = '';
      let initialValue = '';

      if (activeCell === 0) {
        elId = `item-${activeCol}-${activeRow}-title`;
        initialValue = item.title;
      } else if (activeCell === 1) {
        elId = `item-${activeCol}-${activeRow}-start`;
        initialValue = formatDateTime(item.start);
      } else if (activeCell === 2) {
        elId = `item-${activeCol}-${activeRow}-end`;
        initialValue = formatDateTime(item.end);
      }

      const el = document.getElementById(elId);
      if (!el) return;

      const input = document.createElement('input');
      input.value = initialValue;
      input.className = "editing-input";
      // 時刻編集の場合は幅を少し調整してもいいが、一旦CSS任せ

      el.innerHTML = '';
      el.appendChild(input);
      input.focus();
      input.select();

      const finishEdit = () => {
        if (!isEditing) return;

        let success = true;
        if (activeCell === 0) {
          item.title = input.value;
        } else {
          try {
            // 時刻パース
            const originalDate = activeCell === 1 ? item.start : item.end;
            const newDate = parseDateTime(input.value, originalDate);
            if (activeCell === 1) item.start = newDate;
            else item.end = newDate;
          } catch (e) {
            console.error(e);
            success = false;
            // エラー時は元の値を戻すなどの処理が必要だが、今回は簡易的にリセットされる
          }
        }

        isEditing = false;
        render(); // 再描画でinputが消え、新しい値が表示される
        if (success) save(item);
      };

      input.onblur = () => {
        // blur時の確定を防ぎたい場合（誤操作防止）はここを調整するが、
        // 基本的にはフォーカス外れたら保存でよい
        finishEdit();
      };

      input.onkeydown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          input.blur(); // これがonblurを呼び出し、finishEditが走る
        }
        // Tabキーで確定して次の要素へ移動
        if (e.key === 'Tab') {
          e.preventDefault();
          // onblurが発火する前に処理してしまうか、あるいはフラグ管理するか。
          // シンプルにここでfinishEdit相当を行い、moveTabする

          // input.blur()を呼ぶとonblurと競合するので、
          // 手動で値を反映してisEditingをfalseにする
          let success = true;
          if (activeCell === 0) item.title = input.value;
          else {
            try {
              const originalDate = activeCell === 1 ? item.start : item.end;
              const newDate = parseDateTime(input.value, originalDate);
              if (activeCell === 1) item.start = newDate;
              else item.end = newDate;
            } catch (e) { success = false; }
          }
          isEditing = false;
          if (success) save(item);
          moveTab(e.shiftKey ? -1 : 1);
          // renderはmoveTab内で呼ばれるが、activeCellが変わった後の状態になる
          // ここではrender不要（moveTabが呼ぶ）だが、save呼び出しタイミングに注意
        }
        if (e.key === 'Escape') {
          isEditing = false;
          render(); // 元に戻る
        }
        e.stopPropagation();
      };
    }

    /**
     * 文字列からDateオブジェクトを生成する
     * 対応フォーマット:
     * - HHmm (例: 1430 -> 当日14:30)
     * - HH:mm (例: 14:30 -> 当日14:30)
     * - M/D HH:mm (例: 1/22 15:00 -> 本年1/22 15:00)
     * - YYYY/MM/DD HH:mm (例: 2026/01/22 15:00)
     */
    function parseDateTime(str, baseDate) {
      str = str.trim();

      // 数字のみ4桁 (HHmm)
      if (/^\d{4}$/.test(str)) {
        const hh = parseInt(str.substring(0, 2));
        const mm = parseInt(str.substring(2, 4));
        const d = new Date(baseDate);
        d.setHours(hh, mm, 0, 0);
        return d;
      }

      // HH:mm
      if (/^\d{1,2}:\d{2}$/.test(str)) {
        const [hh, mm] = str.split(':').map(Number);
        const d = new Date(baseDate);
        d.setHours(hh, mm, 0, 0);
        return d;
      }

      // それ以外はDate.parseに任せるが、補完が必要
      // 今年の日付として解釈させるなどのロジック
      // 単純に new Date(str) してみる
      const d = new Date(str);
      if (!isNaN(d.getTime())) {
        // "1/22" などを入れると過去(2001年とか)になったりするので注意が必要だが、
        // Chrome環境だと "1/22 10:00" -> "20xx/01/22 10:00" と現在年補完が効くことが多い。
        // ただ、明示的に年が入っていない場合は今年の年をセットするなどの安全策をとる。

        // 年が指定されていないと判断される場合（1900年代や2001年になる場合）
        if (d.getFullYear() < 2000) {
          d.setFullYear(new Date().getFullYear());
        }
        return d;
      }

      throw new Error("Invalid Date Format");
    }

    function create() {
      const base = new Date(columns[activeCol].date);
      const now = getRoundedNow();
      base.setHours(now.getHours(), now.getMinutes(), 0, 0);

      const newItem = { id: null, title: "", start: base, end: new Date(base.getTime() + 3600000) };
      columns[activeCol].items.push(newItem);
      activeRow = columns[activeCol].items.length - 1;
      activeCell = 0;
      render();
      setTimeout(() => startEdit(newItem), 10);
    }

    function del() {
      const items = columns[activeCol].items;
      if (!items[activeRow]) return;
      undoStack = { item: JSON.parse(JSON.stringify(items[activeRow])), col: activeCol, row: activeRow };
      undoStack.item.start = new Date(undoStack.item.start);
      undoStack.item.end = new Date(undoStack.item.end);
      if (items[activeRow].id) {
        setStatus('DELETING...');
        google.script.run.withSuccessHandler(() => setStatus('DELETED')).deleteEvent(items[activeRow].id);
      }
      items.splice(activeRow, 1);
      activeRow = Math.max(0, activeRow - 1);
      render();
    }

    function undo() {
      if (!undoStack) return;
      columns[undoStack.col].items.splice(undoStack.row, 0, undoStack.item);
      const restored = columns[undoStack.col].items[undoStack.row];
      activeCol = undoStack.col; activeRow = undoStack.row;
      save(restored);
      undoStack = null;
      render();
    }

    function adjust(item, dir) {
      const d = dir * STEP * 60000;
      if (activeCell === 1) item.start = new Date(item.start.getTime() + d);
      else if (activeCell === 2) item.end = new Date(item.end.getTime() + d);
      else { item.start = new Date(item.start.getTime() + d); item.end = new Date(item.end.getTime() + d); }
      render();
      debounceSave(item);
    }

    function getRoundedNow() {
      const now = new Date();
      const minutes = now.getMinutes();
      const roundedMinutes = Math.round(minutes / 15) * 15;
      now.setMinutes(roundedMinutes);
      now.setSeconds(0);
      now.setMilliseconds(0);
      return now;
    }

    function debounceSave(item) {
      setStatus('WAITING...');
      const timerKey = item.id || `temp-${activeCol}-${activeRow}`;
      if (debounceTimers[timerKey]) clearTimeout(debounceTimers[timerKey]);
      debounceTimers[timerKey] = setTimeout(() => { save(item); delete debounceTimers[timerKey]; }, 700);
    }

    function save(item) {
      setStatus('SYNCING...');
      const payload = { ...item, start: item.start.toISOString(), end: item.end.toISOString() };
      google.script.run.withSuccessHandler(id => { item.id = id; setStatus('READY'); }).upsertEvent(payload);
    }

    function setStatus(msg) {
      const s = document.getElementById('status');
      if (s) s.innerText = msg;
    }

    refresh();
  </script>
</body>

</html>