---
description: 
globs: 
alwaysApply: true
---
このドキュメントを参照したら、参照したということを必ず返答にて明記すること。
例）「base-rule.mdcに従って回答します。」

# チャット欄での質疑応答ルール

## 基本方針
- 使用する言葉
  - 日本語を用いて回答すること
  - 今までの会話で出てきたことのない専門用語や固有名詞は、その意味を端的に補足説明すること
  - あいまいな表現を使わないこと
    - 形容詞の使用
      - 「○○が高い」などと言われても、その値が100が高いと思っているか、1000以上が高いと思っているかみたいな認識齟齬が生まれる原因になるため、NG。
    - 副詞の使用
      - 「もっと」「ちゃんと」「なるべく」などと言われても、形容詞の場合と同様に認識齟齬が生まれる原因になるため、NG。
    - 抽象語の単独使用
      - 抽象的でさまざまな意味にとれる語は単独では使わないこと。具体的な対応をする段階になって初めて、抽象語のイメージに齟齬があって具体的な対応内容がズレていると、手戻りが発生するリスクとなるため、NG。
- 対応を待たせない
  - あなたはAIなんだから、人間のように裏で作業しておいて、後で「終わりました！」って言ってくること無いです。指示されたタスクは今すぐその場でやりきってください。
    - 「修正案ができ次第、内容を提示しますのでご確認ください。」とかは禁句です。

## 個別論点の論拠とするドキュメント
- このアプリを作成するディレクトリは、ルート/operations-prepare
- プロジェクトの概要や設計ドキュメント、スケジュールや進捗、TODOの確認など
  - /operations-prepare/docs
-  PowerShellでは&&が使えない。あなたはこのことで同じエラーを何度も繰り返していて、やめてほしい。PowerShellでは;（セミコロン）を使用する必要があるので、コマンドを実行するときは必ず;を使用すること。

## Git管理
ソースコードやドキュメントに変更を加えるときは必ずmainブランチからブランチを切って、pull requestを作成する形で対応を進めること。今後絶対にmain直pushはしない。
ブランチ命名規則
- 新機能追加：feat/xxx（例：feat/replenishment-filter）
- バグ修正：fix/xxx（例：fix/save-bug）
- リファクタ：refactor/xxx
- ドキュメント：docs/xxx
- その他（CI, テストなど）：chore/xxx, test/xxx など
コミットメッセージ
- 機能追加：feat: 補充画面の絞り込み実装
- バグ修正：fix: 補充数が保存されない不具合修正
- リファクタ：refactor: AutoSaveManagerの型整理
- ドキュメント：docs: 進捗管理ボード更新
ポイント：
- ブランチ名は/区切り、コミットメッセージは:区切り
- 英語でも日本語でもOK

# 開発ルール

## 基本方針 

- データ中心のシステム設計を採用
  - DBの状態やデータ型がアプリケーションの挙動を決定
  - データモデルを中心に設計を進める
- ソースコードへのベタ書き禁止
  - 日本語の直接記述は不可
  - マジックナンバーの使用は不可
  - すべての値は定数クラス、区分値、ラベル、メッセージで一元管理

## 設計ドキュメント
- ソース構成に合わせたドキュメント配置
  - コンポーネント単位（.vueファイル）
  - API単位（.javaファイル）
  - 双方向リンクによる追跡可能性の確保
- ドキュメント形式
  - マークダウン記法を使用
  - 図表はMermaidを使用
    - 状態遷移図
    - ER図
    - フローチャート
    - 画面遷移図
    - Gitダイアグラム
    - マインドマップ
    - ブロック図
    - アーキテクチャ図
- ドキュメントの更新
  - ソース改修時は必ず対応するドキュメントも更新すること
  - 陳腐化防止の徹底

## 改修プロセス
リポジトリの中身は好きに確認していいし、いちいちユーザーに確認も不要。
1. 事前相談（必須）
   - 要望・課題点の共有
     - ユーザーからの要望や課題点を明確に理解
     - 背景や文脈を共有
   - 根本原因と業務目的の分析
     - なぜその要望が出ているのか
     - 本来の業務上の目的は何か
     - 期待する成果は何か
   - 現状分析
     - DBの状態確認
     - APIの実装確認
     - フロントエンドの実装確認
     - 必要に応じてログの確認
     - 事実ベースでの整理
   - 対応案の提案（3案以上必須）
     - 各案の特徴を整理
       - 実装の複雑さ
       - 影響範囲
       - 保守性
       - 拡張性
       - パフォーマンス
     - メリット・デメリットでの整理は禁止。
     - それぞれの特徴を整理してどの部分を重視するか比較検討できるようにすること
       - 選択肢ごとに、いくつかの判断根拠となる項目同士で比較できるように表形式にして説明すること
     - 複数の選択肢を比較検討するときは表形式で、同じものの内容の説明は階層構造のメモで説明すること
     - 推奨案の選定理由を明確に説明
       - 今回の開発で重視すべき点
       - 選定の根拠
     - 各比較項目ごとの判定悔過をそうだと判断した根拠も明確に回答すること
       - 例えば、拡張性：〇△×と回答するなら、なにを根拠や基準に〇と△を分けたのかを明記すること
     - DBアクセスはlib/db-service.ts（Repository層）で一元管理し、API Route/UseCase層以外から直接呼ばない
     - 業務ロジック・ViewModel変換・バリデーションはlib/utils/xxx-utils.ts等（UseCase層）で管理
     - API Route（app/api/xxx/route.ts）はController層として、クライアントとの唯一の窓口とする
     - クライアントサイドはAPI Route経由でのみデータ取得・更新を行う
   - 合意形成
     - 提案内容の詳細な説明
     - 質問や懸念点への回答
     - 明確な合意の確認
     - 合意が取れるまでは実装開始不可
2. ドキュメントへの反映（必ず、絶対に実施すること。改修した機能に対応するドキュメントがなければ、作成を進言すること）
  - 対応順序
    - 既存ドキュメントがあるdocsフォルダを読み込んで、どのファイルにどういう内容の追加・変更・削除が必要かを、リストアップして確認をとる
      - 齟齬があれば修正イメージをすり合わせする
  - 各ドキュメントへ反映
     - 対応内容
       - 設計ドキュメントの更新
         - 必要に応じてコメントの追加・更新
       - Mermaid記法の図や、markdownの表などの図表の更新
       - \docs\progress\議事録に、その日の日付の議事録ドキュメントで、対応内容の記録を残す。
  - どういう目的のときにどのドキュメントを直したのかを、ドキュメント変更パターンメモ.mdに記録する
    - 今後同じような目的でドキュメントを変更する際の模範とするため。
       - 例）【依存ライブラリ追加】の場合
        - \architecture\技術選定.md
        - ...（docs配下の編集が必要なファイルを、docs配下の相対パス形式でリストアップする）
3. 改修実施
  - どの設計ドキュメントの記載情報をもとに実装するのかを認識合わせ
  - 最大限、Reactの思想に沿った実装にすること。合っていない場合は、どういう理由で合わせた方が良いのかも説明し、変更を提案すること。
  - 改修の実施
    - このアプリ全体の方針として、画面はなるべく全部chadcn/uiのコンポーネント使って実装すること。固有実装がどうしても必要な場合は、そのUIで良いのか、もっと一般的なUIでchadcn/uiのコンポーネントを使えるUIにならないか確認を取ること
    - 変数や関数、コンポーネント、テーブル、カラムなどの命名規則は以下の定義ファイルに従うこと。定義ファイルにない文言を使う場合は、どういう名称がいいか、必ず相談し、定義ファイルに追加してから実装すること。テキトーに変な命名をするとあとから修正がめちゃくちゃ大変なので、絶対に適当な命名を行わないこと。
        - \operations-prepare\docs\naming-conventions.yml
    - ソースコード生成やコマンド実行など
    - linterエラーがでたら、必ず解消されるまで対応し切ること
  - 変更理由と内容の説明（チャット）
    - 変更の背景
    - 具体的な変更内容
    - 影響範囲
    - 期待される効果
  - テストコードの実装
    - ユニットテストの追加・更新
    - E2Eテストの追加・更新
    - テストケースの網羅性確認
  - テスト結果の確認
    - すべてのテストが正常終了することの確認
    - エラーや警告の解消
    - 動作確認の実施
    - 問題が解消されるまで繰り返し

4. 完了確認
   - すべてのテストが正常終了
   - ドキュメントが最新化されている
   - コードレビューが完了
   - 動作確認が完了
   - ユーザー承認が得られている

## ラベル・メッセージ管理
- 表示テキストは `labels.ts` で一元管理
- エラーメッセージは `messages.ts` で一元管理
- 記号やスペースは `SYMBOLS` 定数で管理
- 例：
  ```typescript
  export const SYMBOLS = {
    COLON: ': ',
    SPACE: ' '
  } as const;
  ```

## 区分値管理
- 区分値は `enum-definitions.yaml` で一元管理
- 区分値の表示名は `displayName` を使用
- 区分値のコードは `code` を使用
- 区分値の論理名は `logicalName` を使用

## 型定義
- インターフェースは `types` ディレクトリで管理
- 共通の型定義は `common.ts` に集約
- 型の命名規則は PascalCase
- プロパティの命名規則は camelCase

## コンポーネント設計
- コンポーネントは `views` と `components` で分離
- 再利用可能なコンポーネントは `components` に配置
- ページ単位のコンポーネントは `views` に配置
- スタイルは scoped で管理

## 状態管理
- グローバルな状態は Pinia で管理
- ローカルな状態はコンポーネント内で管理
- 状態の更新は必ず mutation を通じて行う

## エラーハンドリング
- エラーメッセージは `messages.ts` で管理

## テスト
- ソースコードの改修時は必ずテストコードを作成
- テストケースは仕様書として機能するように記述
- テストがNGの場合は改修をやり直し、エラーが解消されるまで繰り返し
- ユニットテストは Jest で記述
- E2Eテストは Cypress で記述
- テストファイルは `__tests__` ディレクトリに配置
- CI/CDで毎回テストを実行可能な状態を維持

## 設計ドキュメント参照
以下のドキュメントを常に参照し、開発を進める：
- `docs/アプリケーション作成指示記録.md`
- `docs/アプリケーション概念設計ノート.md`
- `docs/アプリケーション開発残タスク管理.md`

### 親子コンポーネント間の状態管理ベストプラクティス

1. 単一責任原則（Single Source of Truth）

状態（state）はできるだけ“親”で一元管理し、子はpropsで受け取るだけにする
子は「表示・入力UI」として振る舞い、状態の“変更要求”のみ親に伝える

2. コントロールドコンポーネント

入力欄（Input, Switch等）はvalueもonChangeもpropsで受け取る（コントロールド）
子は「今の値」と「変更時のコールバック」だけをpropsで受け、ローカルstateは持たない

3. 変更通知の仕組み

子で入力があったらonChangeやonStatusChangeで親に「どう変えたいか」を伝える
親はその内容でstateを更新し、再レンダリング時に新しい値を子に渡す

4. パフォーマンス最適化

子が多い場合はReact.memoやuseCallbackで不要な再レンダリングを防ぐ
状態の粒度を細かく分け、必要な部分だけ再レンダリング

5. ローカルstateの使いどころ

入力中の一時的な値（未確定値）や、UIの開閉状態（例：メモ欄の開閉）は子でローカルstate管理してもよい
ただし「確定値」は必ず親で一元管理

6. サンプル実装

```js
// 親
const [items, setItems] = useState<ItemStatus[]>(...);

const handleItemChange = (itemId, field, value) => {
  setItems(prev => prev.map(item =>
    item.id === itemId ? { ...item, [field]: value } : item
  ));
};

<InventoryItemCard
  value={item.currentStock}
  onChange={v => handleItemChange(item.id, 'currentStock', v)}
  // ...他のprops
/>

// 子
<Input
  value={props.value}
  onChange={e => props.onChange(Number(e.target.value))}
/>
```


7. 禁止事項

業務的な確定値を子コンポーネントのローカルstateで管理すること
親と子で同じ値を別々に管理し、同期が取れなくなる実装
propsの変化で毎回ローカルstateを上書きし、入力中の値が消える・戻るような実装

8. 適用範囲

すべてのフォーム、入力UI、業務データを扱う画面・コンポーネントに本ルールを適用すること
このルールに従い、親子コンポーネント間の状態管理を厳密に設計・実装すること。

