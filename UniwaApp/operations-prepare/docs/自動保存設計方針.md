# 自動保存機能の改善方針

## 現状の課題

- 各画面で個別に自動保存の実装が必要
- 設定値の重複
- 型安全性の確保が不十分
- テストが書きづらい

## 改善案

### 1. 基本設定の一元管理

```typescript
// lib/constants/auto-save.ts
export const AUTO_SAVE = {
  DEBOUNCE_MS: 1000,
  STORAGE_PREFIX: {
    INVENTORY: 'inventory',
    ORDER: 'order',
    // 他の画面のプレフィックス
  },
} as const;
```

### 2. カスタムフックの実装

```typescript
// lib/hooks/use-auto-save.ts
type AutoSaveConfig<T> = {
  items: T[];
  saveData: (items: T[]) => Promise<void>;
  getDirtyItems: (items: T[]) => T[];
  prefix: keyof typeof AUTO_SAVE.STORAGE_PREFIX;
  params: Record<string, string | number>;
};

export const useAutoSave = <T extends { id: string }>({
  items,
  saveData,
  getDirtyItems,
  prefix,
  params,
}: AutoSaveConfig<T>) => {
  // 自動保存のロジック
};
```

### 3. 使用例

```typescript
// 画面での使用例
const autoSaveRef = useAutoSave({
  items: itemsRef.current.map(vm => vm.status).filter(...),
  saveData: saveInventoryStatusesBulk,
  getDirtyItems: getDirtyInventoryStatuses,
  prefix: 'INVENTORY',
  params: {
    date: selectedDate.toISOString().split('T')[0],
    placeId: selectedPlaceId
  }
});
```

### 4. 状態表示用コンポーネント

```typescript
// components/ui/auto-save-status.tsx
export const AutoSaveStatus = ({
  autoSaveManager,
}: {
  autoSaveManager: AutoSaveManager | null;
}) => {
  // 保存状態の表示
  // エラー表示
  // 再試行ボタン
};
```

## メリット

1. 自動保存の設定が一元管理
2. 型安全性の確保
3. 画面ごとの実装がシンプルに
4. 自動保存の状態表示が統一
5. テストが書きやすい

## デメリット

1. 初期実装のコスト
2. 画面ごとの特殊な要件への対応が必要な場合がある

## 実装手順

1. 基本設定の一元管理
2. カスタムフックの実装
3. 状態表示用コンポーネントの実装
4. 既存画面への適用
5. テストの実装
