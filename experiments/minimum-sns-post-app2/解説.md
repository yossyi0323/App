完全初学者向けに、超詳しく解説します！

## 文字数制限機能の実装（完全ガイド）

---

## Part 1: エラー型の追加

### 現在のコード（errors.rs）

```rust
#[derive(Error, Debug)]
pub enum AppError {
    #[error("投稿が見つかりません: ID {0}")]
    PostNotFound(String),

    #[error("投稿内容が空です")]
    EmptyContent,
```

### 追加するコード

```rust
    #[error("投稿は{min}文字以上{max}文字以内で入力してください（現在: {current}文字）")]
    ContentLengthInvalid { min: usize, max: usize, current: usize },
```

### 1行ずつ解説

#### `#[error(...)]`

**これは何？**
- `thiserror`クレート（ライブラリ）の**属性マクロ**
- エラーメッセージのテンプレートを定義する

**JavaScriptとの比較**：
```javascript
// JavaScript版
class ContentLengthInvalidError extends Error {
  constructor(min, max, current) {
    super(`投稿は${min}文字以上${max}文字以内で入力してください（現在: ${current}文字）`);
  }
}
```

Rustでは`#[error(...)]`と書くだけで、上記のJavaScriptコードと同じことが自動生成されます。

#### プレースホルダー `{min}` `{max}` `{current}`

**これは何？**
- 変数の値を埋め込む場所
- JavaScriptの`` `文字列 ${変数}` ``と同じ

**ルール**：
```rust
// {0}, {1}, {2}... → タプル型の場合
PostNotFound(String)  // {0}が最初の値

// {name} → 構造体型の場合
ContentLengthInvalid { min: usize, max: usize, current: usize }
// {min}, {max}, {current}がそれぞれの値
```

#### `ContentLengthInvalid { min: usize, max: usize, current: usize }`

**これは何？**
- **構造体的なenumバリアント**
- エラーに複数のデータを持たせたいときに使う

**JavaScriptとの比較**：
```javascript
// JavaScript版
const error = {
  type: 'ContentLengthInvalid',
  min: 10,
  max: 500,
  current: 8
};
```

```rust
// Rust版
AppError::ContentLengthInvalid {
    min: 10,
    max: 500,
    current: 8
}
```

#### `usize`型

**これは何？**
- **u**nsigned（符号なし） **size**（サイズ）
- 0以上の整数（負の数はない）
- 配列の長さ、文字数など「数える」用途に使う

**型の種類**：
```rust
i32   // 整数（-2,147,483,648 〜 2,147,483,647）
u32   // 整数（0 〜 4,294,967,295）
i64   // もっと大きい整数
usize // プラットフォーム依存（32bitなら32bit、64bitなら64bit）
f64   // 小数（JavaScriptのNumber相当）
```

---

## Part 2: バリデーション関数の修正

### 現在のコード（models/post.rs）

```23:31:minimum-sns-post-app2/server/src/models/post.rs
impl CreatePostRequest {
    pub fn validate(&self) -> Result<(), String> {
        if self.content.trim().is_empty() {
            return Err("content は空にできません".to_string());
        }
        Ok(())
    }
}
```

### 修正後のコード

```rust
impl CreatePostRequest {
    pub fn validate(&self) -> Result<(), String> {
        let len = self.content.trim().chars().count();
        
        if len == 0 {
            return Err("content は空にできません".to_string());
        }
        
        if len < 10 || len > 500 {
            return Err(format!(
                "投稿は10文字以上500文字以内で入力してください（現在: {}文字）",
                len
            ));
        }
        
        Ok(())
    }
}
```

### 1行ずつ解説

#### `impl CreatePostRequest`

**これは何？**
- `CreatePostRequest`構造体に**メソッド**を追加する
- JavaScriptのクラスメソッドと同じ

**JavaScriptとの比較**：
```javascript
class CreatePostRequest {
  validate() {
    // メソッド
  }
}
```

```rust
struct CreatePostRequest { /* ... */ }

impl CreatePostRequest {
    fn validate(&self) -> Result<(), String> {
        // メソッド
    }
}
```

Rustでは構造体の定義（`struct`）とメソッドの定義（`impl`）を分けて書きます。

#### `pub fn validate(&self) -> Result<(), String>`

**分解すると**：
- `pub`：public、外部から呼べる
- `fn`：function、関数定義
- `validate`：関数名
- `(&self)`：このメソッドを呼ぶインスタンス自身への参照
- `-> Result<(), String>`：返り値の型

**`&self`とは？**

```rust
// &selfあり → メソッド（インスタンスに対して呼ぶ）
request.validate()  // requestのvalidateメソッド

// &selfなし → 関連関数（構造体名で呼ぶ）
String::from("hello")  // Stringの関連関数
```

**JavaScriptとの比較**：
```javascript
class CreatePostRequest {
  validate() {  // this.validateで呼べる
    if (this.content.trim() === '') { ... }
  }
}
```

```rust
impl CreatePostRequest {
    fn validate(&self) -> Result<(), String> {  // request.validateで呼べる
        if self.content.trim().is_empty() { ... }
    }
}
```

Rustの`&self`はJavaScriptの`this`に相当します。

#### `-> Result<(), String>`

**これは何？**
- 関数の返り値の型
- `Result<成功の型, 失敗の型>`

**今回の場合**：
- 成功の型：`()`（ユニット型、「何も返さない」の意味）
- 失敗の型：`String`（エラーメッセージ）

**なぜ`()`？**
- バリデーションは「OKかNGか」だけ知りたい
- OKなら特に値は不要 → `()`

**JavaScriptとの比較**：
```javascript
// JavaScript版
function validate() {
  if (error) {
    throw new Error("エラーメッセージ");
  }
  // 成功したら何も返さない（暗黙的にundefined）
}
```

```rust
// Rust版
fn validate(&self) -> Result<(), String> {
    if error {
        return Err("エラーメッセージ".to_string());
    }
    Ok(())  // 成功を明示的に返す
}
```

Rustは成功も明示的に`Ok(())`と書きます。

#### `let len = self.content.trim().chars().count();`

**分解すると**：
1. `self.content`：この構造体の`content`フィールド（`String`型）
2. `.trim()`：前後の空白を削除（JavaScriptと同じ）
3. `.chars()`：文字のイテレータを作成
4. `.count()`：文字数を数える
5. `let len =`：結果を変数`len`に代入

**なぜ`.chars()`が必要？**

Rustの文字列は**UTF-8バイト列**なので、そのまま`.len()`すると**バイト数**になります。

```rust
let s = "こんにちは";
s.len()          // 15（バイト数）
s.chars().count() // 5（文字数）
```

日本語対応のために`.chars().count()`を使います。

**JavaScriptとの比較**：
```javascript
const len = this.content.trim().length;  // JavaScriptは自動で文字数
```

```rust
let len = self.content.trim().chars().count();  // Rustは明示的に
```

#### `if len < 10 || len > 500`

**これは何？**
- 条件分岐（JavaScriptと同じ）
- `||`：論理OR（または）

**演算子**：
```rust
&&  // 論理AND（かつ）
||  // 論理OR（または）
!   // 論理NOT（否定）
==  // 等しい
!=  // 等しくない
<   // 小さい
>   // 大きい
<=  // 以下
>=  // 以上
```

JavaScriptと同じです。

#### `return Err(format!("...", len));`

**`format!`マクロ**：
- 文字列を組み立てるマクロ
- JavaScriptの`` `文字列 ${変数}` ``と同じ

**使い方**：
```rust
let name = "太郎";
let age = 25;

format!("名前: {}, 年齢: {}", name, age)
// 結果: "名前: 太郎, 年齢: 25"

format!("名前: {name}, 年齢: {age}")  // 変数名を直接指定もできる
// 結果: "名前: 太郎, 年齢: 25"
```

**`Err(...)`**：
- `Result`型の失敗を表す
- `Err(エラー値)`で作成

**`.to_string()`**：
- 文字列リテラル（`"..."`）を`String`型に変換
- `format!`は既に`String`なので不要

#### `Ok(())`

**これは何？**
- `Result`型の成功を表す
- `Ok(値)`で作成
- 今回は値が不要なので`Ok(())`

**なぜ`()`？**
```rust
// 成功時に値を返す場合
Ok(42)  // Result<i32, String>

// 成功時に値が不要な場合
Ok(())  // Result<(), String>
```

JavaScriptの`return;`（何も返さない）に相当します。

---

## Part 3: エラー型の追加（詳細版）

### 追加するコード（再掲）

```rust
#[error("投稿は{min}文字以上{max}文字以内で入力してください（現在: {current}文字）")]
ContentLengthInvalid { min: usize, max: usize, current: usize },
```

### 使い方

**エラーの作成**：
```rust
// バリデーション関数内で
if len < 10 || len > 500 {
    return Err(AppError::ContentLengthInvalid {
        min: 10,
        max: 500,
        current: len
    });
}
```

**エラーメッセージ**：
```rust
// ユーザーが8文字入力した場合
AppError::ContentLengthInvalid { min: 10, max: 500, current: 8 }
// ↓ 自動で以下のメッセージになる
"投稿は10文字以上500文字以内で入力してください（現在: 8文字）"
```

**なぜ便利？**
- エラーメッセージのフォーマットを一箇所で管理
- 同じエラーを複数箇所で使っても、メッセージが統一される

---

## Part 4: 完全な実装例

### errors.rs（完全版）

```rust
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("投稿が見つかりません: ID {0}")]
    PostNotFound(String),

    #[error("投稿内容が空です")]
    EmptyContent,
    
    // ← ここに追加
    #[error("投稿は{min}文字以上{max}文字以内で入力してください（現在: {current}文字）")]
    ContentLengthInvalid { min: usize, max: usize, current: usize },

    #[error("データベースエラー: {0}")]
    DatabaseError(#[from] sqlx::Error),

    #[error("内部サーバーエラー: {0}")]
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::PostNotFound(id) => (
                StatusCode::NOT_FOUND,
                json!({ "error": format!("投稿が見つかりません: ID {}", id) }),
            ),
            AppError::EmptyContent => (
                StatusCode::BAD_REQUEST,
                json!({ "error": "content は空にできません" }),
            ),
            // ← ここに追加
            AppError::ContentLengthInvalid { min, max, current } => (
                StatusCode::BAD_REQUEST,
                json!({ 
                    "error": format!(
                        "投稿は{}文字以上{}文字以内で入力してください（現在: {}文字）",
                        min, max, current
                    )
                }),
            ),
            AppError::DatabaseError(ref e) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": format!("データベースエラー: {}", e) }),
            ),
            AppError::InternalError(ref e) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": format!("内部サーバーエラー: {}", e) }),
            ),
        };

        (status, Json(error_message)).into_response()
    }
}

pub type AppResult<T> = Result<T, AppError>;
```

### models/post.rs（完全版）

```rust
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct Post {
    pub id: Uuid,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Deserialize)]
pub struct CreatePostRequest {
    pub content: String,
}

#[derive(Debug, Deserialize)]
pub struct UpdatePostRequest {
    pub content: String,
}

impl CreatePostRequest {
    pub fn validate(&self) -> Result<(), String> {
        // 文字数をカウント（UTF-8対応）
        let len = self.content.trim().chars().count();
        
        // 空チェック
        if len == 0 {
            return Err("content は空にできません".to_string());
        }
        
        // 文字数制限チェック
        if len < 10 || len > 500 {
            return Err(format!(
                "投稿は10文字以上500文字以内で入力してください（現在: {}文字）",
                len
            ));
        }
        
        Ok(())
    }
}

impl UpdatePostRequest {
    pub fn validate(&self) -> Result<(), String> {
        // CreatePostRequestと同じロジック
        let len = self.content.trim().chars().count();
        
        if len == 0 {
            return Err("content は空にできません".to_string());
        }
        
        if len < 10 || len > 500 {
            return Err(format!(
                "投稿は10文字以上500文字以内で入力してください（現在: {}文字）",
                len
            ));
        }
        
        Ok(())
    }
}
```

---

## Part 5: 各構文の詳細解説

### `let len = ...`

**これは何？**
- 変数宣言
- JavaScriptの`const`と同じ（デフォルトでイミュータブル）

**書き方**：
```rust
let x = 5;        // イミュータブル（変更不可）
x = 10;          // コンパイルエラー！

let mut y = 5;   // ミュータブル（変更可）
y = 10;          // OK
```

**型推論**：
```rust
let x = 5;           // 型を書かなくても、i32と推論される
let y: i32 = 5;      // 明示的に型を書いてもOK
let s = "hello";     // &str（文字列スライス）と推論される
```

### `self.content.trim()`

**これは何？**
- `self.content`：この構造体の`content`フィールド（`String`型）
- `.trim()`：前後の空白・改行を削除

**JavaScriptとの比較**：
```javascript
this.content.trim()  // JavaScript
```

```rust
self.content.trim()  // Rust
```

完全に同じです。

### `.chars()`

**これは何？**
- 文字列を**文字単位**で扱えるイテレータに変換

**なぜ必要？**

Rustの文字列は**UTF-8バイト列**として保存されています。

```rust
let s = "こんにちは";

// バイト数
s.len()  // 15（UTF-8で「こ」は3バイト × 5文字 = 15バイト）

// 文字数
s.chars().count()  // 5
```

**イテレータとは？**
- 要素を順番に処理できるもの
- JavaScriptの配列メソッドチェーンと似ている

```javascript
// JavaScript
[1, 2, 3].map(x => x * 2).filter(x => x > 2)

// Rust
[1, 2, 3].iter().map(|x| x * 2).filter(|x| x > &2).collect()
```

### `.count()`

**これは何？**
- イテレータの要素数を数える

```rust
"hello".chars().count()  // 5

[1, 2, 3].iter().count()  // 3
```

### `if len < 10 || len > 500`

**演算子の意味**：
- `<`：小さい（less than）
- `||`：または（or）
- `>`：大きい（greater than）

**読み方**：
「lenが10より小さい、**または**、lenが500より大きい場合」

### `return Err(...)`

**これは何？**
- 関数から早期リターン（途中で抜ける）
- エラー値を返す

**なぜ`return`が必要？**

Rustでは最後の式が自動でreturnされますが、途中で抜けたい場合は`return`を書きます。

```rust
fn example(x: i32) -> Result<i32, String> {
    if x < 0 {
        return Err("負の数です".to_string());  // ここで終了
    }
    
    Ok(x * 2)  // returnを書かなくてもOK（最後の式）
}
```

### `format!(...)`

**これは何？**
- 文字列を組み立てるマクロ
- `!`がついているのはマクロの印

**書き方**：
```rust
let name = "太郎";
let age = 25;

// 位置指定
format!("名前: {}, 年齢: {}", name, age)

// 名前指定
format!("名前: {name}, 年齢: {age}")

// 数値フォーマット
format!("割合: {:.2}%", 95.555)  // "割合: 95.56%"
```

**JavaScriptとの比較**：
```javascript
`名前: ${name}, 年齢: ${age}`  // JavaScript
```

```rust
format!("名前: {name}, 年齢: {age}")  // Rust
```

ほぼ同じです。

### `Ok(())`

**これは何？**
- 成功を表す値
- `()`は「値なし」を意味する

**`()`の意味**：
```rust
fn do_something() -> () {  // 返り値なし
    println!("何かする");
    ()  // 何も返さない
}

// 省略形（同じ意味）
fn do_something() {  // -> ()は省略可能
    println!("何かする");
    // 最後の()も省略可能
}
```

JavaScriptの`void`や`undefined`に似ています。

---

## Part 6: 動作確認手順

### 1. コードを修正

上記の通り、2ファイルを修正してください。

### 2. サーバー再起動

```powershell
# サーバーのウィンドウで Ctrl+C で停止
# その後
cargo run
```

### 3. ブラウザで確認

`http://localhost:8080`で：

**テスト1: 8文字入力**
```
あいうえお123  (8文字)
```
→ エラーメッセージ表示されるはず

**テスト2: 11文字入力**
```
あいうえおかきくけこ  (10文字)
```
→ 投稿成功するはず

### 4. エラーメッセージの確認方法

**ブラウザのコンソール（F12）で**：
- Networkタブ → POSTリクエスト → Response
- エラーメッセージのJSONが見えます

```json
{
  "error": "投稿は10文字以上500文字以内で入力してください（現在: 8文字）"
}
```

---

## おまけ：よくある疑問

### Q1: `&self`と`self`の違いは？

```rust
fn method1(&self) { }       // 借用（読み取り専用）
fn method2(&mut self) { }   // ミュータブル借用（変更可能）
fn method3(self) { }        // 所有権を奪う（メソッド後にインスタンス使えなくなる）
```

**99%は`&self`を使います。**

### Q2: `String`と`&str`の違いは？

```rust
String  // 所有する文字列（ヒープに確保、長さ変更可能）
&str    // 借用した文字列（参照のみ、読み取り専用）

let s1: String = "hello".to_string();  // String
let s2: &str = "hello";                // &str
```

**使い分け**：
- 構造体のフィールド：`String`（所有したい）
- 関数の引数：`&str`（借用でOK）

### Q3: `?`演算子の詳細

```rust
// これは
let result = some_function()?;

// これと同じ
let result = match some_function() {
    Ok(value) => value,
    Err(e) => return Err(e),
};
```

エラーの場合、即座に関数からreturnします。

---

さあ、実装してみてください！

動かしてみて、分からないところや「これどういう意味？」があったら何でも聞いてください。

**ポイント**：
- コピペでOK（理解は後からでも）
- まず動かしてみる
- エラーメッセージを読んでみる
- コンパイラが親切に教えてくれます