# 機能要件定義書

## 基本方針

- **実用性重視：** 実際に使える機能を優先
- **段階的開発：** Phase 1から始めて、使っていく中で育てていく
- **複雑さへの対応：** ストックの種類やレシピの関係性など、複雑な要件も考慮する

## レシピの本質的な定義

### 概念モデル

**食材 = データ、レシピ = プログラム（メソッド）**

- **食材（データ）：** インプットとして使われるもの
- **レシピ（メソッド）：** 材料をインプットに、処理プロセスを経て、アウトプット（料理や中間段階のもの）を生成する
- **処理の流れ：**
	1. 材料（食材）をインプットにする
	2. レシピに書いてある処理プロセスを経る
	3. アウトプットとして料理や料理の中間段階のものが出来上がる
	4. その中間段階のものと他の材料を組み合わせてインプットにする
	5. 完成させる手順を踏んで最終的にまた料理ができる

### レシピの表現方法

- **表面的な表現：** OrderedList（手順）として「〇〇を一口大にカットして炒める」のようにテキストで書く
- **本質的な定義：** **組み合わせ可能な処理プロセス、引数と戻り値を持つメソッド**として定義されるべき
- **レシピ同士の関係性：** メソッドの呼び出しとして表現される
	- 例：カレー = ポトフ（レシピAのアウトプット） + カレー粉（食材） → レシピBのインプット
	- 例：トマトソース（レシピAのアウトプット） → トマトソースパスタ（レシピB）のインプット

### レシピの構造の複雑さ

#### レシピ名とプロセスとアウトプットの区別

- **レシピ名：** 一般的には「ポトフ」という料理名で呼ばれる
- **レシピのプロセス：** 「ポトフの作り方」という処理プロセス
- **アウトプット：** プロセスを経て「ポトフという料理」が出来上がる
- **内部構造：** レシピ名、プロセス、アウトプットは区別して管理する必要がある

#### 複数の戻り値を持つ関数

レシピは複数のアウトプットを返す可能性がある：

- **主なアウトプット：** レシピの主目的となる料理や中間成果物
	- 例：出汁を取る → 主なアウトプットは「出汁」
- **副産物：** プロセスの中で副次的に生成されるもの
	- 例：出汁を取る → 副産物として「出し殻の昆布と鰹節」が残る
	- 副産物は捨てる場合もあるが、他のレシピの材料として使える場合もある（例：出し殻はふりかけの材料にできる）

**データモデル設計への影響：**
- レシピは複数のアウトプット（主なアウトプット + 副産物）を返す関数として定義する必要がある
- 副産物もストックとして管理できるようにする
- 副産物が他のレシピの材料になる可能性も考慮する

#### 1つのアウトプットが複数のレシピのインプットになる（1対多の関係）

1つのレシピのアウトプットが、複数の異なるレシピのインプットになる場合がある：

- **例：肉そぼろ（ひき肉を炒めたアウトプット）**
	- そのまま肉そぼろとしてご飯にかける（完成品として使う）
	- ザージャンとして麻婆豆腐の材料にする（他のレシピのインプット）
	- ビビンバの具にする（他のレシピのインプット）

**データモデル設計への影響：**
- 1つのアウトプットが複数のレシピのインプットになる「1対多」の関係を表現できる必要がある
- ストック（レシピのアウトプット）から、それをインプットに使う複数のレシピを逆引きできる必要がある
- 検索時に「このストックで作れるレシピ一覧」を表示できるようにする

#### 共通プロセスの再利用と全体調整（トータルコーディネート）

レシピは単なるプロセスの集合ではなく、全体を見て調整が必要：

- **共通プロセスの再利用：** 同じプロセスが複数のレシピで使われる
	- 例：パスタを茹でるというプロセスは、パスタの種類や茹で時間に差があるとはいえ、だいたい共通
	- パスタソースは多種多様だが、パスタを茹でる部分は共通
- **全体の調整・トータルコーディネート：** レシピ全体の文脈から、共通プロセスのパラメータを調整する必要がある
	- 例：ペペロンチーノにしらすとレモンを入れる場合
		- しらすが塩味を持つ → 茹でるお湯の塩分濃度を下げる必要がある
		- 単純に「パスタを茹でる」を呼び出すのではなく、レシピ全体の文脈から塩加減を調整する
- **プログラミングの例え：** 共通関数（パスタを茹でる）のパラメータ（茹で時間、塩加減）を、呼び出し元のレシピ全体の文脈から調整する必要がある

**データモデル設計への影響：**
- 共通プロセスを再利用できる構造が必要
- レシピ全体の文脈から、共通プロセスのパラメータを調整できる必要がある
- 単純な関数の呼び出しではなく、文脈に応じたパラメータ調整を表現できる必要がある
- 例：パスタを茹でるプロセスの「塩加減」パラメータを、レシピ全体の材料（しらすなど）に応じて調整する

#### レシピの構造の複雑さの認識

- **レシピの構造は非常に複雑：** 単純なインプット→アウトプットの関係ではない
- **多層的な構造：** レシピ名、プロセス、アウトプット、副産物、メソッドの呼び出しチェーン、1対多の関係、共通プロセスの再利用と全体調整など
- **データモデル設計時の注意：** この複雑さを適切に表現できる設計が必要

### 食材の状態遷移

#### 状態遷移の概念

食材は調理過程で「状態」が変わる。これは「中間成果物」とは異なる概念：

- **中間成果物：** レシピのアウトプット（例：トマトソース、出汁）
- **状態遷移：** 食材そのものの状態が変わる（例：葉野菜が洗われた状態になる、ひき肉が焼かれた状態になる）

**具体例：**

1. **葉野菜の状態遷移**
	- 葉野菜（生） → 洗う → 葉野菜（水気あり） → サラダスピナー → 葉野菜（水気なし）
	- 各状態で使えるレシピが異なる（サラダには水気なしが必要、炒め物には水気ありでも可）

2. **ひき肉の状態遷移**
	- ひき肉（生） → 焼く → そぼろ（焼いた状態）
	- そぼろ（焼いた状態）は複数のレシピの材料になる：
		- そのままそぼろ丼として使える（完成品として）
		- ミートソースの材料になる（他のレシピのインプット）
		- 麻婆豆腐のザージャンとして使える（他のレシピのインプット）
		- ビビンバの具として使える（他のレシピのインプット）

#### 状態遷移の正規化と汎用性

**正規化の必要性：**

食材の状態遷移は正規化して扱う必要がある。なぜなら、同じ処理が複数の食材に適用できるから：

- **汎用的な処理：** 「焼く」は魚にも肉にも適用できる
- **汎用的な処理：** 「洗う」は葉野菜にも根菜にも適用できる
- **汎用的な処理：** 「切る」は多くの食材に適用できる

**正規化された構造：**

1. **食材マスタ（ingredients）**
	- 食材の基本情報（名前、カテゴリなど）
	- 例：魚、肉、葉野菜、ひき肉

2. **処理マスタ（processes）**
	- 汎用的な処理の定義
	- 例：焼く、洗う、切る、茹でる、炒める
	- **汎用性のレベル：**
		- **高汎用性：** 焼く、洗う、切る（多くの食材に適用可能）
		- **中汎用性：** 茹でる（パスタ、野菜など、特定のカテゴリに適用可能）
		- **低汎用性：** そぼろを作る（ひき肉専用、でも「焼く」の特殊ケースとも言える）

**処理の抽象化・共通化の難しさ：**

処理（焼く、煮る、切る、削る）も、それぞれが道具や食材を選ぶ動作であり、厳密にすればするほど扱いづらく細かくなる：

- **「焼く」の詳細：** フライパンで焼く、オーブンで焼く、網で焼く、温度、時間、油の有無など
- **「煮る」の詳細：** 鍋で煮る、圧力鍋で煮る、温度、時間、調味料の有無など
- **「切る」の詳細：** 包丁で切る、スライサーで切る、切り方（みじん切り、千切り、輪切りなど）、大きさなど
- **「削る」の詳細：** ピーラーで削る、包丁で削る、厚さなど

**抽象化の階層：**

処理を抽象化・階層化することで共通化できる可能性がある：

1. **処理のカテゴリ（抽象レベル）**
	- 加熱：焼く、煮る、炒める、蒸す、揚げる
	- 加工：切る、削る、刻む、すりおろす
	- 調味：塩を振る、味付けする、マリネする
	- 準備：洗う、水に浸す、水気を切る

2. **処理のパラメータ**
	- 道具：フライパン、鍋、包丁、オーブンなど
	- 温度：高温、中温、低温
	- 時間：短時間、中時間、長時間
	- 調味料：塩、コショウ、油など

**共通化の難しさと実用性のバランス：**

- **厳密にすればするほど扱いづらく細かくなる：** 完璧な正規化を目指すと、使うのが大変になる
- **共通化しないと重複が増える：** 同じような処理が重複して定義される
- **実用性とのバランス：** 使う人が実際に使えるレベルで抽象化・共通化する必要がある
	- Phase 1：処理は「焼く」「煮る」「切る」など、シンプルな名前で管理（道具や詳細は手順に記載）
	- Phase 2以降：処理のカテゴリやパラメータを段階的に追加（使ってみて必要になったら追加）

3. **状態遷移テーブル（ingredient_state_transitions）**
	- 食材 × 処理 → 新しい状態
	- 例：
		- 魚 + 焼く → 魚（焼けた状態）
		- 肉 + 焼く → 肉（焼けた状態）
		- 葉野菜 + 洗う → 葉野菜（水気あり）
		- ひき肉 + 焼く → そぼろ（焼けた状態）

**「そぼろ」の扱い：**

「そぼろ」は以下の2つの解釈が可能：

1. **「ひき肉（焼けた状態）」として扱う**
	- ひき肉 + 焼く → ひき肉（焼けた状態）
	- 利点：汎用的な処理「焼く」で表現できる
	- 問題点：「そぼろ」という名前で呼ばれることが多い

2. **「そぼろ」という別の食材として扱う**
	- ひき肉 + 焼く → そぼろ（新しい食材）
	- 利点：「そぼろ」という名前で管理できる
	- 問題点：処理の汎用性が失われる

**設計方針：**

- **基本は正規化：** 食材マスタ、処理マスタ、状態遷移テーブルで正規化
- **処理の汎用性を重視：** 「焼く」は魚にも肉にも適用できる構造にする
- **名前の柔軟性：** 状態遷移後の食材に「別名」を付けられるようにする
	- 例：ひき肉（焼けた状態）の別名 = 「そぼろ」
	- 例：魚（焼けた状態）の別名 = 「焼き魚」
- **プログラマブルなプロセス：** 料理をプログラマブルなプロセスとしてデザイン
	- 処理は関数として定義
	- 食材はデータとして定義
	- 状態遷移は関数の適用として定義

#### データモデル設計への影響

**正規化された構造の必要性：**

1. **食材マスタ（ingredients）テーブル**
	- 食材の基本情報（名前、カテゴリなど）を管理
	- 例：`id, name, category, created_at, updated_at`
	- **必須：** 正規化の基礎となる

2. **処理マスタ（processes）テーブル**
	- 汎用的な処理の定義を管理
	- **Phase 1の設計：** `id, name, description, category, created_at, updated_at`
		- シンプルな構造：処理名（焼く、煮る、切るなど）とカテゴリ（加熱、加工、調味など）のみ
		- 道具や詳細なパラメータは手順（steps）に記載
	- **Phase 2以降の拡張：** パラメータを追加できる構造
		- `parameters (JSON)`：道具、温度、時間、調味料などのパラメータを柔軟に管理
		- 例：`{"tool": "フライパン", "temperature": "中火", "time": "5分", "oil": true}`
	- **汎用性のレベル：**
		- 高汎用性：焼く、洗う、切る
		- 中汎用性：茹でる、炒める
		- 低汎用性：そぼろを作る（特殊ケース）
	- **必須：** 処理の再利用を可能にする
	- **実用性とのバランス：** 厳密にすればするほど扱いづらく細かくなるため、段階的に抽象化・共通化する

3. **状態遷移テーブル（ingredient_state_transitions）**
	- 食材 × 処理 → 新しい状態の定義
	- 例：`id, ingredient_id, process_id, output_state_name, output_state_alias, created_at, updated_at`
	- **別名（alias）の必要性：**
		- 例：ひき肉（焼けた状態）の別名 = 「そぼろ」
		- 例：魚（焼けた状態）の別名 = 「焼き魚」
	- **必須：** 状態遷移の正規化

4. **ストックの状態管理**
	- ストックテーブルに`ingredient_id`と`state_transition_id`を追加
	- 例：ストック「そぼろ」= `ingredient_id: ひき肉, state_transition_id: 焼く`
	- **必須：** ストックと状態遷移の紐づけ

**レシピと状態のマッチング：**

1. **レシピの材料指定**
	- レシピの材料指定時に状態を考慮するか
	- 例：「葉野菜（水気なし）」が必要なレシピ vs 「葉野菜（任意の状態）」で良いレシピ
	- **設計方針：**
		- レシピの材料指定は`ingredient_id`と`required_state_transition_id`（任意）で表現
		- `required_state_transition_id`がNULLなら任意の状態でOK

2. **ストックとレシピのマッチング**
	- ストックの状態とレシピの要求状態をどうマッチングするか
	- **マッチングロジック：**
		- レシピの`required_state_transition_id`がNULL → 任意の状態でマッチ
		- レシピの`required_state_transition_id`が指定されている → ストックの`state_transition_id`と一致する必要がある

**プログラマブルなプロセスの実現：**

- **処理は関数として定義：** 処理マスタで汎用的な処理を定義
- **食材はデータとして定義：** 食材マスタで食材を定義
- **状態遷移は関数の適用として定義：** 状態遷移テーブルで「食材 + 処理 → 新しい状態」を定義
- **レシピはメソッドとして定義：** 引数（材料、状態）と戻り値（アウトプット）を持つ

**処理の抽象化・共通化の難しさ：**

処理（焼く、煮る、切る、削る）も、それぞれが道具や食材を選ぶ動作であり、厳密にすればするほど扱いづらく細かくなる：

- **抽象化の階層：** 処理をカテゴリ（加熱、加工、調味など）で分類し、共通化できる部分を抽出
- **パラメータの管理：** 道具、温度、時間、調味料などのパラメータをどう管理するか
- **実用性とのバランス：** 完璧な正規化を目指すと使うのが大変になるため、段階的に抽象化・共通化する
	- Phase 1：処理はシンプルな名前で管理（道具や詳細は手順に記載）
	- Phase 2以降：処理のカテゴリやパラメータを段階的に追加（使ってみて必要になったら追加）

**設計方針：**

- **Phase 1：** 状態遷移は簡易的に扱う
	- ストックに「状態メモ」を追加（自由入力）
	- レシピの材料指定は「食材名」のみ
	- マッチング時は食材名のみで判断（状態は考慮しない）
	- **データモデルは拡張可能に設計：** 食材マスタ、処理マスタ、状態遷移テーブルの追加を考慮
	- **処理マスタはシンプルに：** 処理名（焼く、煮る、切るなど）とカテゴリのみ（道具や詳細は手順に記載）
- **Phase 2以降：** 状態遷移の本格的な管理（正規化）
	- 食材マスタ（ingredients）テーブルの導入
	- 処理マスタ（processes）テーブルの導入
	- 状態遷移テーブル（ingredient_state_transitions）の導入
	- ストックテーブルに`ingredient_id`と`state_transition_id`を追加
	- レシピの材料指定に`ingredient_id`と`required_state_transition_id`（任意）を追加
	- ストックの状態とレシピの要求状態のマッチングロジック

## 実装方針：複雑な構造への段階的アプローチ

### 基本方針

**Phase 1では概念を理解しつつ、実装はシンプルに。データモデルは拡張可能に設計し、使っていく中で必要な複雑さを段階的に追加する。**

### Phase 1：シンプルな実装

**実装する構造：**
- レシピテーブル：`id, name, ingredients (JSON), steps (JSON), youtube_url, created_at, updated_at`
- ストックテーブル：`id, name, type (完成品/中間成果物/食材), recipe_id (どのレシピから作られたか), used_in_recipe_ids (JSON, どのレシピの材料になるか), state_memo (食材の状態メモ、自由入力), frozen_at, location_memo`
- レシピとストックの紐づけは、ストックテーブルの`recipe_id`と`used_in_recipe_ids`で実現
- 食材の状態遷移は、ストックテーブルの`state_memo`で簡易的に管理（Phase 1）

**実装しない構造（将来の拡張として設計に含める）：**
- メソッドの呼び出しチェーン：レシピの`ingredients`に他のレシピのIDを含められるようにする（Phase 2以降）
- 複数の戻り値（副産物）：ストックテーブルに`is_byproduct`フラグを追加できるようにする（Phase 2以降）
- 食材の状態遷移の本格的な管理（正規化）：食材マスタ、処理マスタ、状態遷移テーブル、レシピと状態のマッチング（Phase 2以降）
	- **食材マスタ（ingredients）テーブル：** 食材の基本情報を管理
	- **処理マスタ（processes）テーブル：** 汎用的な処理（焼く、洗う、切るなど）を管理
	- **状態遷移テーブル（ingredient_state_transitions）：** 食材 × 処理 → 新しい状態を定義
	- **ストックテーブルに`ingredient_id`と`state_transition_id`を追加：** ストックと状態遷移の紐づけ
	- **レシピの材料指定に`ingredient_id`と`required_state_transition_id`（任意）を追加：** レシピと状態のマッチング
- 共通プロセスの再利用：レシピテーブルに`process_template_id`を追加できるようにする（Phase 3以降）
- 全体調整：レシピテーブルに`parameter_overrides (JSON)`を追加できるようにする（Phase 3以降）

### データモデル設計の具体的な方針

**拡張性の確保方法：**

1. **JSONカラムの活用**
	- `ingredients (JSON)`：将来、他のレシピのIDを含められるようにする
	- `used_in_recipe_ids (JSON)`：1対多の関係を表現できるようにする
	- `parameter_overrides (JSON)`：共通プロセスのパラメータ調整を表現できるようにする

2. **外部キー制約を緩く設計**
	- ストックの`recipe_id`は外部キーにするが、`used_in_recipe_ids`はJSONで柔軟に管理
	- 将来、レシピ同士の関係テーブルを追加できるようにする

3. **マイグレーション戦略**
	- Phase 1ではシンプルな構造で実装
	- Phase 2以降で、必要に応じてカラム追加やテーブル追加を行う
	- 既存データとの互換性を保つ

### 実装の優先順位

**Phase 1：**
1. ストックの種類とレシピとの基本的な紐づけ（必須）
2. 基本レシピのCRUD（必須）
3. ストック優先フィルター（必須）

**Phase 1.5：**
1. アレンジレシピの基本的な継承構造（コア機能）

**Phase 2：**
1. 1対多の関係の完全実装（`used_in_recipe_ids`の活用）
2. メソッドの呼び出しチェーン（レシピの`ingredients`に他のレシピのIDを含める）
3. 食材の状態遷移の本格的な管理（食材マスタ、状態遷移テーブル、レシピと状態のマッチング）
4. **コンテキストによるパラメータ調整ロジックの検討（設計レビューで指摘）**
	- **検討事項：** 「しらすを入れるから茹で汁の塩分を引く」といったトータルコーディネートのロジックの実装方法
	- **実装方針の検討：**
		- レシピ実行時に、各材料が持つ属性（例：`salt_content`）を動的に集計し、処理（`boil`）のパラメータを上書きする「ミドルウェア」的な処理ロジックの定義
		- 材料の属性管理方法（PRODUCTSテーブルに属性カラムを追加するか、別テーブルで管理するか）の検討
		- レシピ実行エンジンの設計（共通プロセスのパラメータを、レシピ全体の文脈から調整する仕組み）

**Phase 3以降：**
1. 複数の戻り値（副産物）の管理
2. 共通プロセスの再利用
3. 全体調整・トータルコーディネート

### 実装時の注意点

- **完璧を目指さない：** 最初から全ての複雑さを実装しようとしない
- **使ってから判断：** 実際に使っていく中で、どの複雑さが必要か判断する
- **データモデルの拡張性：** JSONカラムや外部キーを活用して、将来の拡張に対応できる設計にする

### データモデル設計への影響

この概念モデルをデータモデル設計時に反映する必要がある：

- **レシピはメソッドとして定義：** 引数（材料）と戻り値（アウトプット）を持つ
- **複数の戻り値：** 主なアウトプットと副産物の両方を管理できるようにする
- **レシピ名、プロセス、アウトプットの区別：** これらを適切に分離して管理する
- **レシピ同士の関係性：** メソッドの呼び出しチェーンとして表現
- **1対多の関係：** 1つのアウトプットが複数のレシピのインプットになる関係を表現できる必要がある
- **共通プロセスの再利用：** 同じプロセスが複数のレシピで使われる構造を表現できる必要がある
- **全体調整・トータルコーディネート：** レシピ全体の文脈から、共通プロセスのパラメータを調整できる必要がある
	- 単純な関数の呼び出しではなく、文脈に応じたパラメータ調整を表現できる必要がある
- **ストックとレシピの関係：** ストックはレシピのアウトプット（戻り値、主なものも副産物も）またはインプット（引数）として扱われる
	- ストック（アウトプット）から、それをインプットに使う複数のレシピを逆引きできる必要がある
- **レシピの構造の複雑さ：** この複雑さを適切に表現できる設計が必要

## 主要機能の概要

### 1. レシピ管理機能

**目的：** レシピ情報を集約し、柔軟に管理・検索できるようにする

**概要：**
- 基本レシピの登録・編集・削除
- アレンジレシピの登録・編集・削除
- レシピ一覧・詳細表示
- YouTube動画へのリンク
- タグ付けによる分類・検索

**複雑さへの対応：**
- **レシピの組み合わせ：** カレー = ポトフ + カレー粉のような、レシピが他のレシピの材料になる構造に対応
- **アレンジレシピ：** トマトソース → トマトソースパスタ、アラビアータ、ペンネアラビアータ、カチャトーラ風、トマトスープなど、様々なアレンジに対応
- **継承構造：** 基本レシピとアレンジレシピの関係を管理

### 2. ストック管理機能

**目的：** 冷凍庫のストックを把握し、献立決定に活用する

**概要：**
- ストックの登録・編集・削除
- ストック一覧表示
- 冷凍開始日の記録
- 消費推奨アラート（1ヶ月以上経過）
- 場所メモ

**複雑さへの対応：**
- **ストックの種類：** 以下の3種類を区別して管理
	- **完成品：** ミートソース、カレーなど、そのまま食べられるもの
	- **中間成果物：** 肉のつけ置きなど、まだ調理が必要なもの
	- **食材：** ひき肉の小分けなど、食材として使うもの
- **分類の難しさ：** 「食材なのか完成品なのか中間成果物なのか」という分類を、ユーザーが選択できるようにする
- **食材の状態遷移：** 食材の状態（例：葉野菜の水気あり/なし、ひき肉の生/焼いた）を管理する必要がある
	- **Phase 1：** 状態は「メモ」として自由入力（簡易対応）
	- **Phase 2以降：** 状態遷移の本格的な管理（食材マスタ、状態遷移の定義）
- **レシピとの関係：** ストックがどのレシピの材料になるか、またはどのレシピから作られたかを紐づけられるようにする
	- **重要：** これはコア機能であり、後回しにはできない。このアプリの核心に近い部分

### 3. 献立提案機能

**目的：** ストック情報を活用して、作れるレシピを提案する

**概要：**
- ストック優先フィルター（ワンクリック）
- タグによる検索・フィルター
- 高度な検索（AND/OR/NOT）
- 作り置きからの提案

**複雑さへの対応：**
- **ストックとレシピのマッチング：** ストックの種類（完成品、中間成果物、食材）に応じて、適切なレシピを提案
- **レシピの組み合わせ：** カレー = ポトフ + カレー粉のような構造に対応した検索
- **アレンジレシピ：** 基本レシピとアレンジレシピの両方を検索対象にする

## 各機能の詳細要件（検討事項）

### レシピ管理機能

#### 基本レシピ登録

**検討事項：**
- レシピ名、材料、手順、YouTube URL、タイムスタンプの入力方法
- 材料の管理方法（食材として登録するのか、自由入力なのか）
- レシピが他のレシピの材料になる場合の扱い（例：トマトソースがトマトソースパスタの材料になる）

#### アレンジレシピ登録

**検討事項（コア機能）：**
- 基本レシピとの関係の管理方法
- 追加・変更材料の記録方法
- **手順の継承方法：** 基本レシピの手順を継承するのか、完全に別にするのか
	- **重要：** このアプリが解決したい複雑さの核心部分
- **多階層の可能性：** アレンジレシピからさらにアレンジレシピを作れるか
	- **重要：** このアプリが解決したい複雑さの核心部分

#### タグ付けシステム

**検討事項：**
- タグの種類（材料、味、調理時間など）
- タグの管理方法（事前定義なのか、自由入力なのか）
- タグによる検索・フィルターのUI

#### YouTube連携

**方針：**
- **シンプルに実装：** テキストエリアにURLを入れるだけ
- **プレイヤー不要：** アプリ内にプレイヤーは実装しない
- **外部アプリで再生：** スマホならYouTubeアプリで見たい
- **タイムスタンプ：** 必要に応じてURLにタイムスタンプを含める（例：`?t=120`）

### ストック管理機能

#### ストック登録

**検討事項：**
- ストック名の入力方法（完成品、中間成果物、食材の区別）
- ストックの種類の選択方法（完成品/中間成果物/食材）
- 量の入力方法（2食分、大、など）
- 食材の状態メモの入力方法（Phase 1：自由入力、Phase 2以降：状態遷移から選択）
- 冷凍開始日の入力方法（デフォルトは今日）
- 場所メモの入力方法

#### ストック一覧表示

**検討事項：**
- 一覧の表示方法（カード、リスト）
- 消費推奨アラートの表示方法（1ヶ月以上経過したストックを目立つように）
- ソート・フィルター機能（種類、日付など）

#### ストック消費

**検討事項：**
- 消費方法（削除なのか、量を減らすのか）
- 部分消費の扱い（2食分のうち1食分を使った場合）

### 献立提案機能

#### ストック優先フィルター

**検討事項：**
- ストックとレシピのマッチングロジック
	- 完成品：そのまま使えるレシピを提案
	- 中間成果物：その中間成果物を使うレシピを提案
	- 食材：その食材を使うレシピを提案
- 複数のストックがある場合の扱い
- ストックがない材料も必要になる場合の扱い

#### 高度な検索フィルター

**検討事項：**
- タグによる検索（AND/OR/NOT）
- キーワード検索
- 複合条件の検索

#### 作り置きからの提案

**検討事項：**
- 作り置き（完成品）から、それを応用したレシピを提案する方法
- 例：ミートソース → ドリア、スパゲッティなど
- レシピとストックの紐づけ方法

## 優先順位（Phase 1 / 拡張機能）

### Phase 1: 基礎機能

**目標：** 基本的なレシピ管理とストック管理ができる

1. **レシピ管理（基本）**
	- 基本レシピの登録・編集・削除
	- レシピ一覧・詳細表示
	- YouTube URLの保存（テキストエリアに入力、外部アプリで再生）

2. **ストック管理（基本）**
	- ストックの登録・編集・削除
	- **ストックの種類の選択（完成品/中間成果物/食材）** - **コア機能**
	- **ストックとレシピの紐づけ** - **コア機能**
		- ストックがどのレシピの材料になるか
		- ストックがどのレシピから作られたか
	- ストック一覧表示
	- 冷凍開始日の記録
	- 消費推奨アラート（1ヶ月以上経過）

3. **基本的な検索**
	- レシピ一覧の表示
	- **ストック優先フィルター（ワンクリック）**
		- ストックの種類に応じた適切なレシピ提案
		- 完成品：そのまま使えるレシピを提案
		- 中間成果物：その中間成果物を使うレシピを提案
		- 食材：その食材を使うレシピを提案

4. **認証**
	- Google認証

5. **PWA対応**
	- ホーム画面にアイコンを追加できる

**Phase 1での複雑さへの対応：**
- **ストックの種類とレシピとの関係はコア機能として実装**（後回しにはできない）
- **アレンジレシピの継承構造はデータモデル設計時に必須で考慮**（Phase 1.5またはPhase 2で実装するが、データモデルは最初から対応）

### Phase 1.5: アレンジレシピ機能（コア機能）

**目標：** アレンジレシピの基本機能を実装

1. **アレンジレシピ**
	- 基本レシピの子としてアレンジレシピを登録
	- アレンジレシピ一覧表示
	- **手順の継承方法の実装** - **コア機能**
	- **多階層の可能性への対応** - **コア機能**
	- **重要：** データモデル設計時に事前に念頭に置いておく必要がある

### Phase 2: 拡張機能

**目標：** より便利に使える機能を追加

1. **食材の状態遷移の本格的な管理（正規化）**
	- 食材マスタ（ingredients）テーブルの導入
	- 処理マスタ（processes）テーブルの導入
	- 状態遷移テーブル（ingredient_state_transitions）の導入
	- ストックテーブルに`ingredient_id`と`state_transition_id`を追加
	- レシピの材料指定に`ingredient_id`と`required_state_transition_id`（任意）を追加
	- ストックの状態とレシピの要求状態のマッチングロジック
	- **プログラマブルなプロセス：** 処理を関数として定義し、食材をデータとして定義、状態遷移を関数の適用として定義

2. **タグ機能**
	- レシピにタグを付けられる
	- タグでの検索・フィルター

3. **高度な検索**
	- 複数タグのAND/OR/NOT検索
	- 作り置きからの提案

4. **場所メモ**
	- ストックに場所メモを追加

5. **タイムスタンプ**
	- YouTube動画のタイムスタンプを保存・ジャンプ

### Phase 3: 将来的な拡張（アイデア）

**今後開発したい機能（メモ）**

1. **単位変換レイヤー（Unit Conversion）**
	- **必要性**: プログラマブルに扱う際、インプットの「大さじ1」と「15ml」、あるいは「玉ねぎ1個」と「200g」をどう計算（キャスト）するかが課題
	- **実装方針**: 
		- INGREDIENTSテーブルに`standard_unit`（標準単位）を追加
		- 容積・重量の変換係数を持たせる「単位変換メソッド」の概念を導入
		- 在庫計算の精度向上
	- **例**: 「大さじ1 = 15ml」「玉ねぎ1個 = 200g」などの変換係数を定義

2. **レシピの依存グラフの可視化**
	- **必要性**: 複雑なレシピチェーンを組むと、何が何に依存しているか把握しづらくなる
	- **実装方針**: 
		- レシピの依存関係をグラフ構造（DAG: Directed Acyclic Graph）として管理
		- 依存グラフを視覚化するUI
		- 循環参照（無限ループ）の検出機能
	- **例**: 「カレー」を起点に、必要な「ポトフ」や「カレー粉」などの依存関係を可視化

3. **レシピが他のレシピの材料になる構造の完全対応**
	- メソッドの呼び出しチェーンの完全実装

4. **YouTube Data API連携**
	- YouTube動画のメタデータを自動取得

5. **レシピの画像アップロード**
	- レシピの画像をアップロードして管理

6. **レシピの評価・お気に入り**
	- レシピの評価機能、お気に入り機能

7. **献立カレンダー**
	- 献立をカレンダー形式で管理

8. **買い物リスト機能**
	- レシピから買い物リストを自動生成

9. **レシピの共有機能**
	- レシピを他のユーザーと共有

## データモデル設計時の重要な検討事項（コア機能）

### ストックの種類とレシピとの関係（コア機能）

**重要：** これはコア機能であり、後回しにはできない。このアプリの核心に近い部分。

**検討すべき点：**
- 完成品、中間成果物、食材をどう区別するか
- **ストックとレシピの関係をどう管理するか** - **必須**
	- ストックがどのレシピの材料になるか
	- ストックがどのレシピから作られたか
- 検索時にストックの種類に応じてどうレシピを提案するか

### アレンジレシピの設計（コア機能）

**重要：** このアプリが解決したい複雑さの核心部分。データモデル設計時に必須で考慮する。

**検討すべき点：**
- 基本レシピとアレンジレシピの継承構造をどう設計するか
- アレンジレシピの追加・変更材料をどう管理するか
- **手順の継承方法：** 基本レシピの手順を継承するのか、完全に別にするのか
	- **重要：** このアプリが解決したい複雑さの核心部分
- **多階層の可能性：** アレンジレシピからさらにアレンジレシピを作れるか
	- **重要：** このアプリが解決したい複雑さの核心部分
- 検索・フィルター時に基本レシピとアレンジレシピをどう扱うか

### レシピの組み合わせ構造（メソッドの呼び出し）

**重要：** レシピは本質的に「引数と戻り値を持つメソッド」として定義されるべき。

**検討すべき点：**
- **レシピが他のレシピの材料になる構造：** メソッドの呼び出しチェーンとして表現
	- 例：カレー = ポトフ（レシピAのアウトプット） + カレー粉（食材） → レシピBのインプット
	- 例：トマトソース（レシピAのアウトプット） → トマトソースパスタ（レシピB）のインプット
- **この構造をどうデータモデルで表現するか：**
	- レシピのインプット（引数）として、食材だけでなく他のレシピのアウトプットも指定できる
	- レシピのアウトプット（戻り値）として、完成品だけでなく中間成果物も指定できる
- **検索時にこの構造をどう活用するか：**
	- ストック（レシピのアウトプット）から、それをインプットに使うレシピを逆引きできる
	- レシピのアウトプットから、それを材料に使う他のレシピを検索できる

**設計方針：**
- **ストックの種類とレシピとの関係、アレンジレシピの継承構造、レシピのメソッド呼び出し構造、食材の状態遷移（正規化）は、データモデル設計時に必須で考慮する**
- Phase 1で実装する機能も、Phase 1.5以降で実装する機能も、データモデルは最初から対応する
- 後から追加する際に大きな変更が不要な設計にする
- **レシピを「メソッド」として定義し、引数（材料）と戻り値（アウトプット）を明確にする**
- **食材の状態遷移も「メソッドの呼び出し」として扱える可能性がある**（例：ひき肉（生）→ 焼く → そぼろ（焼いた状態）→ 複数のレシピの材料）
- **正規化と汎用性を重視：** 処理は関数として定義し、食材はデータとして定義、状態遷移は関数の適用として定義
	- 処理マスタで汎用的な処理（焼く、洗う、切るなど）を定義
	- 状態遷移テーブルで「食材 × 処理 → 新しい状態」を定義
	- 同じ処理が複数の食材に適用できる構造にする

### 食材の状態遷移の設計（コア機能）

**重要：** 食材の状態遷移は「中間成果物」とは異なる概念。データモデル設計時に必須で考慮する。**正規化と汎用性を重視した設計が必要。**

**正規化の必要性：**

- **汎用的な処理の再利用：** 「焼く」は魚にも肉にも適用できる
- **処理の汎用性のレベル：**
	- 高汎用性：焼く、洗う、切る（多くの食材に適用可能）
	- 中汎用性：茹でる、炒める（特定のカテゴリに適用可能）
	- 低汎用性：そぼろを作る（特殊ケース、でも「焼く」の特殊ケースとも言える）

**正規化された構造：**

1. **食材マスタ（ingredients）テーブル**
	- 食材の基本情報（名前、カテゴリなど）を管理
	- 例：`id, name, category, created_at, updated_at`
	- **必須：** 正規化の基礎となる

2. **処理マスタ（processes）テーブル**
	- 汎用的な処理の定義を管理
	- 例：`id, name, description, category, created_at, updated_at`
	- **汎用性のレベルを管理：** 高汎用性、中汎用性、低汎用性
	- **必須：** 処理の再利用を可能にする

3. **状態遷移テーブル（ingredient_state_transitions）**
	- 食材 × 処理 → 新しい状態の定義
	- 例：`id, ingredient_id, process_id, output_state_name, output_state_alias, created_at, updated_at`
	- **別名（alias）の必要性：**
		- 例：ひき肉（焼けた状態）の別名 = 「そぼろ」
		- 例：魚（焼けた状態）の別名 = 「焼き魚」
	- **必須：** 状態遷移の正規化

4. **ストックの状態管理**
	- ストックテーブルに`ingredient_id`と`state_transition_id`を追加
	- 例：ストック「そぼろ」= `ingredient_id: ひき肉, state_transition_id: 焼く`
	- **必須：** ストックと状態遷移の紐づけ

**レシピと状態のマッチング：**

- **レシピの材料指定：** `ingredient_id`と`required_state_transition_id`（任意）で表現
	- `required_state_transition_id`がNULLなら任意の状態でOK
- **ストックとレシピのマッチング：**
	- レシピの`required_state_transition_id`がNULL → 任意の状態でマッチ
	- レシピの`required_state_transition_id`が指定されている → ストックの`state_transition_id`と一致する必要がある

**プログラマブルなプロセスの実現：**

- **処理は関数として定義：** 処理マスタで汎用的な処理を定義
- **食材はデータとして定義：** 食材マスタで食材を定義
- **状態遷移は関数の適用として定義：** 状態遷移テーブルで「食材 + 処理 → 新しい状態」を定義
- **レシピはメソッドとして定義：** 引数（材料、状態）と戻り値（アウトプット）を持つ

**処理の抽象化・共通化の難しさ：**

処理（焼く、煮る、切る、削る）も、それぞれが道具や食材を選ぶ動作であり、厳密にすればするほど扱いづらく細かくなる：

- **抽象化の階層：** 処理をカテゴリ（加熱、加工、調味など）で分類し、共通化できる部分を抽出
- **パラメータの管理：** 道具、温度、時間、調味料などのパラメータをどう管理するか
- **実用性とのバランス：** 完璧な正規化を目指すと使うのが大変になるため、段階的に抽象化・共通化する
	- Phase 1：処理はシンプルな名前で管理（道具や詳細は手順に記載）
	- Phase 2以降：処理のカテゴリやパラメータを段階的に追加（使ってみて必要になったら追加）

**設計方針：**

- **Phase 1：** 状態遷移は簡易的に扱う
	- ストックに「状態メモ」を追加（自由入力、TEXT型）
	- レシピの材料指定は「食材名」のみ（状態は考慮しない）
	- マッチング時は食材名のみで判断
	- **データモデルは拡張可能に設計：** 食材マスタ、処理マスタ、状態遷移テーブルの追加を考慮
	- **処理マスタはシンプルに：** 処理名（焼く、煮る、切るなど）とカテゴリのみ（道具や詳細は手順に記載）
- **Phase 2以降：** 状態遷移の本格的な管理（正規化）
	- 食材マスタ（ingredients）テーブルの導入
	- 処理マスタ（processes）テーブルの導入
	- 状態遷移テーブル（ingredient_state_transitions）の導入
	- ストックテーブルに`ingredient_id`と`state_transition_id`を追加
	- レシピの材料指定に`ingredient_id`と`required_state_transition_id`（任意）を追加
	- ストックの状態とレシピの要求状態のマッチングロジック

