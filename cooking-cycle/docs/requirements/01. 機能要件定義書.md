# 機能要件定義書

## 基本方針

- **実用性重視：** 実際に使える機能を優先
- **段階的開発：** Phase 1から始めて、使っていく中で育てていく
- **複雑さへの対応：** ストックの種類やレシピの関係性など、複雑な要件も考慮する

## レシピの本質的な定義

### 概念モデル

**食材 = データ、レシピ = プログラム（メソッド）**

- **食材（データ）：** インプットとして使われるもの
- **レシピ（メソッド）：** 材料をインプットに、処理プロセスを経て、アウトプット（料理や中間段階のもの）を生成する
- **処理の流れ：**
	1. 材料（食材）をインプットにする
	2. レシピに書いてある処理プロセスを経る
	3. アウトプットとして料理や料理の中間段階のものが出来上がる
	4. その中間段階のものと他の材料を組み合わせてインプットにする
	5. 完成させる手順を踏んで最終的にまた料理ができる

### レシピの表現方法

- **表面的な表現：** OrderedList（手順）として「〇〇を一口大にカットして炒める」のようにテキストで書く
- **本質的な定義：** **組み合わせ可能な処理プロセス、引数と戻り値を持つメソッド**として定義されるべき
- **レシピ同士の関係性：** メソッドの呼び出しとして表現される
	- 例：カレー = ポトフ（レシピAのアウトプット） + カレー粉（食材） → レシピBのインプット
	- 例：トマトソース（レシピAのアウトプット） → トマトソースパスタ（レシピB）のインプット

### レシピの構造の複雑さ

#### レシピ名とプロセスとアウトプットの区別

- **レシピ名：** 一般的には「ポトフ」という料理名で呼ばれる
- **レシピのプロセス：** 「ポトフの作り方」という処理プロセス
- **アウトプット：** プロセスを経て「ポトフという料理」が出来上がる
- **内部構造：** レシピ名、プロセス、アウトプットは区別して管理する必要がある

#### 複数の戻り値を持つ関数

レシピは複数のアウトプットを返す可能性がある：

- **主なアウトプット：** レシピの主目的となる料理や中間成果物
	- 例：出汁を取る → 主なアウトプットは「出汁」
- **副産物：** プロセスの中で副次的に生成されるもの
	- 例：出汁を取る → 副産物として「出し殻の昆布と鰹節」が残る
	- 副産物は捨てる場合もあるが、他のレシピの材料として使える場合もある（例：出し殻はふりかけの材料にできる）

**データモデル設計への影響：**
- レシピは複数のアウトプット（主なアウトプット + 副産物）を返す関数として定義する必要がある
- 副産物もストックとして管理できるようにする
- 副産物が他のレシピの材料になる可能性も考慮する

#### 1つのアウトプットが複数のレシピのインプットになる（1対多の関係）

1つのレシピのアウトプットが、複数の異なるレシピのインプットになる場合がある：

- **例：肉そぼろ（ひき肉を炒めたアウトプット）**
	- そのまま肉そぼろとしてご飯にかける（完成品として使う）
	- ザージャンとして麻婆豆腐の材料にする（他のレシピのインプット）
	- ビビンバの具にする（他のレシピのインプット）

**データモデル設計への影響：**
- 1つのアウトプットが複数のレシピのインプットになる「1対多」の関係を表現できる必要がある
- ストック（レシピのアウトプット）から、それをインプットに使う複数のレシピを逆引きできる必要がある
- 検索時に「このストックで作れるレシピ一覧」を表示できるようにする

#### 共通プロセスの再利用と全体調整（トータルコーディネート）

レシピは単なるプロセスの集合ではなく、全体を見て調整が必要：

- **共通プロセスの再利用：** 同じプロセスが複数のレシピで使われる
	- 例：パスタを茹でるというプロセスは、パスタの種類や茹で時間に差があるとはいえ、だいたい共通
	- パスタソースは多種多様だが、パスタを茹でる部分は共通
- **全体の調整・トータルコーディネート：** レシピ全体の文脈から、共通プロセスのパラメータを調整する必要がある
	- 例：ペペロンチーノにしらすとレモンを入れる場合
		- しらすが塩味を持つ → 茹でるお湯の塩分濃度を下げる必要がある
		- 単純に「パスタを茹でる」を呼び出すのではなく、レシピ全体の文脈から塩加減を調整する
- **プログラミングの例え：** 共通関数（パスタを茹でる）のパラメータ（茹で時間、塩加減）を、呼び出し元のレシピ全体の文脈から調整する必要がある

**データモデル設計への影響：**
- 共通プロセスを再利用できる構造が必要
- レシピ全体の文脈から、共通プロセスのパラメータを調整できる必要がある
- 単純な関数の呼び出しではなく、文脈に応じたパラメータ調整を表現できる必要がある
- 例：パスタを茹でるプロセスの「塩加減」パラメータを、レシピ全体の材料（しらすなど）に応じて調整する

#### レシピの構造の複雑さの認識

- **レシピの構造は非常に複雑：** 単純なインプット→アウトプットの関係ではない
- **多層的な構造：** レシピ名、プロセス、アウトプット、副産物、メソッドの呼び出しチェーン、1対多の関係、共通プロセスの再利用と全体調整など
- **データモデル設計時の注意：** この複雑さを適切に表現できる設計が必要

## 実装方針：複雑な構造への段階的アプローチ

### 基本方針

**Phase 1では概念を理解しつつ、実装はシンプルに。データモデルは拡張可能に設計し、使っていく中で必要な複雑さを段階的に追加する。**

### Phase 1：シンプルな実装

**実装する構造：**
- レシピテーブル：`id, name, ingredients (JSON), steps (JSON), youtube_url, created_at, updated_at`
- ストックテーブル：`id, name, type (完成品/中間成果物/食材), recipe_id (どのレシピから作られたか), used_in_recipe_ids (JSON, どのレシピの材料になるか), frozen_at, location_memo`
- レシピとストックの紐づけは、ストックテーブルの`recipe_id`と`used_in_recipe_ids`で実現

**実装しない構造（将来の拡張として設計に含める）：**
- メソッドの呼び出しチェーン：レシピの`ingredients`に他のレシピのIDを含められるようにする（Phase 2以降）
- 複数の戻り値（副産物）：ストックテーブルに`is_byproduct`フラグを追加できるようにする（Phase 2以降）
- 共通プロセスの再利用：レシピテーブルに`process_template_id`を追加できるようにする（Phase 3以降）
- 全体調整：レシピテーブルに`parameter_overrides (JSON)`を追加できるようにする（Phase 3以降）

### データモデル設計の具体的な方針

**拡張性の確保方法：**

1. **JSONカラムの活用**
	- `ingredients (JSON)`：将来、他のレシピのIDを含められるようにする
	- `used_in_recipe_ids (JSON)`：1対多の関係を表現できるようにする
	- `parameter_overrides (JSON)`：共通プロセスのパラメータ調整を表現できるようにする

2. **外部キー制約を緩く設計**
	- ストックの`recipe_id`は外部キーにするが、`used_in_recipe_ids`はJSONで柔軟に管理
	- 将来、レシピ同士の関係テーブルを追加できるようにする

3. **マイグレーション戦略**
	- Phase 1ではシンプルな構造で実装
	- Phase 2以降で、必要に応じてカラム追加やテーブル追加を行う
	- 既存データとの互換性を保つ

### 実装の優先順位

**Phase 1：**
1. ストックの種類とレシピとの基本的な紐づけ（必須）
2. 基本レシピのCRUD（必須）
3. ストック優先フィルター（必須）

**Phase 1.5：**
1. アレンジレシピの基本的な継承構造（コア機能）

**Phase 2：**
1. 1対多の関係の完全実装（`used_in_recipe_ids`の活用）
2. メソッドの呼び出しチェーン（レシピの`ingredients`に他のレシピのIDを含める）

**Phase 3以降：**
1. 複数の戻り値（副産物）の管理
2. 共通プロセスの再利用
3. 全体調整・トータルコーディネート

### 実装時の注意点

- **完璧を目指さない：** 最初から全ての複雑さを実装しようとしない
- **使ってから判断：** 実際に使っていく中で、どの複雑さが必要か判断する
- **データモデルの拡張性：** JSONカラムや外部キーを活用して、将来の拡張に対応できる設計にする

### データモデル設計への影響

この概念モデルをデータモデル設計時に反映する必要がある：

- **レシピはメソッドとして定義：** 引数（材料）と戻り値（アウトプット）を持つ
- **複数の戻り値：** 主なアウトプットと副産物の両方を管理できるようにする
- **レシピ名、プロセス、アウトプットの区別：** これらを適切に分離して管理する
- **レシピ同士の関係性：** メソッドの呼び出しチェーンとして表現
- **1対多の関係：** 1つのアウトプットが複数のレシピのインプットになる関係を表現できる必要がある
- **共通プロセスの再利用：** 同じプロセスが複数のレシピで使われる構造を表現できる必要がある
- **全体調整・トータルコーディネート：** レシピ全体の文脈から、共通プロセスのパラメータを調整できる必要がある
	- 単純な関数の呼び出しではなく、文脈に応じたパラメータ調整を表現できる必要がある
- **ストックとレシピの関係：** ストックはレシピのアウトプット（戻り値、主なものも副産物も）またはインプット（引数）として扱われる
	- ストック（アウトプット）から、それをインプットに使う複数のレシピを逆引きできる必要がある
- **レシピの構造の複雑さ：** この複雑さを適切に表現できる設計が必要

## 主要機能の概要

### 1. レシピ管理機能

**目的：** レシピ情報を集約し、柔軟に管理・検索できるようにする

**概要：**
- 基本レシピの登録・編集・削除
- アレンジレシピの登録・編集・削除
- レシピ一覧・詳細表示
- YouTube動画へのリンク
- タグ付けによる分類・検索

**複雑さへの対応：**
- **レシピの組み合わせ：** カレー = ポトフ + カレー粉のような、レシピが他のレシピの材料になる構造に対応
- **アレンジレシピ：** トマトソース → トマトソースパスタ、アラビアータ、ペンネアラビアータ、カチャトーラ風、トマトスープなど、様々なアレンジに対応
- **継承構造：** 基本レシピとアレンジレシピの関係を管理

### 2. ストック管理機能

**目的：** 冷凍庫のストックを把握し、献立決定に活用する

**概要：**
- ストックの登録・編集・削除
- ストック一覧表示
- 冷凍開始日の記録
- 消費推奨アラート（1ヶ月以上経過）
- 場所メモ

**複雑さへの対応：**
- **ストックの種類：** 以下の3種類を区別して管理
	- **完成品：** ミートソース、カレーなど、そのまま食べられるもの
	- **中間成果物：** 肉のつけ置きなど、まだ調理が必要なもの
	- **食材：** ひき肉の小分けなど、食材として使うもの
- **分類の難しさ：** 「食材なのか完成品なのか中間成果物なのか」という分類を、ユーザーが選択できるようにする
- **レシピとの関係：** ストックがどのレシピの材料になるか、またはどのレシピから作られたかを紐づけられるようにする
	- **重要：** これはコア機能であり、後回しにはできない。このアプリの核心に近い部分

### 3. 献立提案機能

**目的：** ストック情報を活用して、作れるレシピを提案する

**概要：**
- ストック優先フィルター（ワンクリック）
- タグによる検索・フィルター
- 高度な検索（AND/OR/NOT）
- 作り置きからの提案

**複雑さへの対応：**
- **ストックとレシピのマッチング：** ストックの種類（完成品、中間成果物、食材）に応じて、適切なレシピを提案
- **レシピの組み合わせ：** カレー = ポトフ + カレー粉のような構造に対応した検索
- **アレンジレシピ：** 基本レシピとアレンジレシピの両方を検索対象にする

## 各機能の詳細要件（検討事項）

### レシピ管理機能

#### 基本レシピ登録

**検討事項：**
- レシピ名、材料、手順、YouTube URL、タイムスタンプの入力方法
- 材料の管理方法（食材として登録するのか、自由入力なのか）
- レシピが他のレシピの材料になる場合の扱い（例：トマトソースがトマトソースパスタの材料になる）

#### アレンジレシピ登録

**検討事項（コア機能）：**
- 基本レシピとの関係の管理方法
- 追加・変更材料の記録方法
- **手順の継承方法：** 基本レシピの手順を継承するのか、完全に別にするのか
	- **重要：** このアプリが解決したい複雑さの核心部分
- **多階層の可能性：** アレンジレシピからさらにアレンジレシピを作れるか
	- **重要：** このアプリが解決したい複雑さの核心部分

#### タグ付けシステム

**検討事項：**
- タグの種類（材料、味、調理時間など）
- タグの管理方法（事前定義なのか、自由入力なのか）
- タグによる検索・フィルターのUI

#### YouTube連携

**方針：**
- **シンプルに実装：** テキストエリアにURLを入れるだけ
- **プレイヤー不要：** アプリ内にプレイヤーは実装しない
- **外部アプリで再生：** スマホならYouTubeアプリで見たい
- **タイムスタンプ：** 必要に応じてURLにタイムスタンプを含める（例：`?t=120`）

### ストック管理機能

#### ストック登録

**検討事項：**
- ストック名の入力方法（完成品、中間成果物、食材の区別）
- ストックの種類の選択方法（完成品/中間成果物/食材）
- 量の入力方法（2食分、大、など）
- 冷凍開始日の入力方法（デフォルトは今日）
- 場所メモの入力方法

#### ストック一覧表示

**検討事項：**
- 一覧の表示方法（カード、リスト）
- 消費推奨アラートの表示方法（1ヶ月以上経過したストックを目立つように）
- ソート・フィルター機能（種類、日付など）

#### ストック消費

**検討事項：**
- 消費方法（削除なのか、量を減らすのか）
- 部分消費の扱い（2食分のうち1食分を使った場合）

### 献立提案機能

#### ストック優先フィルター

**検討事項：**
- ストックとレシピのマッチングロジック
	- 完成品：そのまま使えるレシピを提案
	- 中間成果物：その中間成果物を使うレシピを提案
	- 食材：その食材を使うレシピを提案
- 複数のストックがある場合の扱い
- ストックがない材料も必要になる場合の扱い

#### 高度な検索フィルター

**検討事項：**
- タグによる検索（AND/OR/NOT）
- キーワード検索
- 複合条件の検索

#### 作り置きからの提案

**検討事項：**
- 作り置き（完成品）から、それを応用したレシピを提案する方法
- 例：ミートソース → ドリア、スパゲッティなど
- レシピとストックの紐づけ方法

## 優先順位（Phase 1 / 拡張機能）

### Phase 1: 基礎機能

**目標：** 基本的なレシピ管理とストック管理ができる

1. **レシピ管理（基本）**
	- 基本レシピの登録・編集・削除
	- レシピ一覧・詳細表示
	- YouTube URLの保存（テキストエリアに入力、外部アプリで再生）

2. **ストック管理（基本）**
	- ストックの登録・編集・削除
	- **ストックの種類の選択（完成品/中間成果物/食材）** - **コア機能**
	- **ストックとレシピの紐づけ** - **コア機能**
		- ストックがどのレシピの材料になるか
		- ストックがどのレシピから作られたか
	- ストック一覧表示
	- 冷凍開始日の記録
	- 消費推奨アラート（1ヶ月以上経過）

3. **基本的な検索**
	- レシピ一覧の表示
	- **ストック優先フィルター（ワンクリック）**
		- ストックの種類に応じた適切なレシピ提案
		- 完成品：そのまま使えるレシピを提案
		- 中間成果物：その中間成果物を使うレシピを提案
		- 食材：その食材を使うレシピを提案

4. **認証**
	- Google認証

5. **PWA対応**
	- ホーム画面にアイコンを追加できる

**Phase 1での複雑さへの対応：**
- **ストックの種類とレシピとの関係はコア機能として実装**（後回しにはできない）
- **アレンジレシピの継承構造はデータモデル設計時に必須で考慮**（Phase 1.5またはPhase 2で実装するが、データモデルは最初から対応）

### Phase 1.5: アレンジレシピ機能（コア機能）

**目標：** アレンジレシピの基本機能を実装

1. **アレンジレシピ**
	- 基本レシピの子としてアレンジレシピを登録
	- アレンジレシピ一覧表示
	- **手順の継承方法の実装** - **コア機能**
	- **多階層の可能性への対応** - **コア機能**
	- **重要：** データモデル設計時に事前に念頭に置いておく必要がある

### Phase 2: 拡張機能

**目標：** より便利に使える機能を追加

1. **タグ機能**
	- レシピにタグを付けられる
	- タグでの検索・フィルター

3. **高度な検索**
	- 複数タグのAND/OR/NOT検索
	- 作り置きからの提案

4. **場所メモ**
	- ストックに場所メモを追加

5. **タイムスタンプ**
	- YouTube動画のタイムスタンプを保存・ジャンプ

### Phase 3: 将来的な拡張（アイデア）

**今後開発したい機能（メモ）**

- レシピが他のレシピの材料になる構造の完全対応
- YouTube Data API連携
- レシピの画像アップロード
- レシピの評価・お気に入り
- 献立カレンダー
- 買い物リスト機能
- レシピの共有機能

## データモデル設計時の重要な検討事項（コア機能）

### ストックの種類とレシピとの関係（コア機能）

**重要：** これはコア機能であり、後回しにはできない。このアプリの核心に近い部分。

**検討すべき点：**
- 完成品、中間成果物、食材をどう区別するか
- **ストックとレシピの関係をどう管理するか** - **必須**
	- ストックがどのレシピの材料になるか
	- ストックがどのレシピから作られたか
- 検索時にストックの種類に応じてどうレシピを提案するか

### アレンジレシピの設計（コア機能）

**重要：** このアプリが解決したい複雑さの核心部分。データモデル設計時に必須で考慮する。

**検討すべき点：**
- 基本レシピとアレンジレシピの継承構造をどう設計するか
- アレンジレシピの追加・変更材料をどう管理するか
- **手順の継承方法：** 基本レシピの手順を継承するのか、完全に別にするのか
	- **重要：** このアプリが解決したい複雑さの核心部分
- **多階層の可能性：** アレンジレシピからさらにアレンジレシピを作れるか
	- **重要：** このアプリが解決したい複雑さの核心部分
- 検索・フィルター時に基本レシピとアレンジレシピをどう扱うか

### レシピの組み合わせ構造（メソッドの呼び出し）

**重要：** レシピは本質的に「引数と戻り値を持つメソッド」として定義されるべき。

**検討すべき点：**
- **レシピが他のレシピの材料になる構造：** メソッドの呼び出しチェーンとして表現
	- 例：カレー = ポトフ（レシピAのアウトプット） + カレー粉（食材） → レシピBのインプット
	- 例：トマトソース（レシピAのアウトプット） → トマトソースパスタ（レシピB）のインプット
- **この構造をどうデータモデルで表現するか：**
	- レシピのインプット（引数）として、食材だけでなく他のレシピのアウトプットも指定できる
	- レシピのアウトプット（戻り値）として、完成品だけでなく中間成果物も指定できる
- **検索時にこの構造をどう活用するか：**
	- ストック（レシピのアウトプット）から、それをインプットに使うレシピを逆引きできる
	- レシピのアウトプットから、それを材料に使う他のレシピを検索できる

**設計方針：**
- **ストックの種類とレシピとの関係、アレンジレシピの継承構造、レシピのメソッド呼び出し構造は、データモデル設計時に必須で考慮する**
- Phase 1で実装する機能も、Phase 1.5以降で実装する機能も、データモデルは最初から対応する
- 後から追加する際に大きな変更が不要な設計にする
- **レシピを「メソッド」として定義し、引数（材料）と戻り値（アウトプット）を明確にする**

