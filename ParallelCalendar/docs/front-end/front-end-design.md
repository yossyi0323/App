# Front-end Design

## 技術スタック

### 使用決定しているツールやライブラリ
- react-big-calendar
- Vite
- React
- TypeScript
- TailwindCSS
- shadcn/ui
- Vitest
- Google認証
- ESLint
- Prettier
- Zod
- OpenAPI
- TanStack Query
- TanStack Router
- Orval
- date-fns
- Redux Toolkit
- React Hook Form
- loglevel

ディレクトリ構成：レイヤーベース成にする
実際のディレクトリ構成は実装しながら、Redux Toolkit・TanStack Query・Router をどの層に置くかを都度検討して決める。

### まだ詳細設計が必要な論点

1. Information / Warning / Error の具体的なメッセージ設計と、Toast・フォーム内メッセージ・ダイアログの使い分け。
2. 画面レイアウト（ログイン画面・カレンダー画面・設定画面などのレイアウトパターン）。
3. 認可（v0.1 では「全ユーザー同じ権限」とし、将来的にロールベースの制御を検討）。
4. ログイン後の画面遷移や、将来的なキーボードショートカット導入時の UX 上の細部。

Playwright？←E2Eは今のフェーズではまだ不要。
- **Auth**: ベーシック認証（将来的にOneLogin/Google認証）

---

## 論点リスト

1.  ルーティング (Routing)
2.  データ取得 (Data Fetching)
3.  APIクライアント (API Client)
4.  状態管理 (State Management)
5.  エラーハンドリング
6.  ログ出力・監視
7.  共通コンポーネントの粒度


---

## 論点1：ルーティング

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: React Router (v6/v7)**
*   **No.2: Next.js (App Router) Built-in**
*   **No.3: TanStack Router**

#### なぜそれがNo1なの？
*   React初期から存在し、圧倒的なドキュメント量とコミュニティがあるため。「迷ったらこれ」という安心感がある。

#### No2の特徴と、No1に劣る点
*   **Next.js Built-in:** Next.jsを使うならこれ一択だが、React単体では使えない。
*   劣る点: フレームワーク（Next.js）にロックインされる。

#### No3の特徴と、No1,2に劣る点
*   **TanStack Router:** 「型安全性 (Type-Safety)」を最優先に設計された新世代ルーター。URLパラメータの変更にコンパイラが気づける。
*   劣る点: 学習コストが少し高い。概念が新しい（ファイルベースルーティングなど）。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **TanStack Router** (No.3)

#### 推奨する理由
あえてNo.1を選ばない理由は、**「URL変更に伴うバグを撲滅したいから」** です。
カレンダーアプリでは `/calendar?view=month&date=2026-02` のようにURLパラメータを多用します。React Router (No.1) はここが弱く、パラメータ名を変えてもエラーが出ず、実行時に動かなくなります。
TanStack Routerなら、コードを書いている最中に赤線が出るため、堅牢性が段違いです。

---

## 論点2：データ取得 (Data Fetching)

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: useEffect + fetch (標準)**
*   **No.2: TanStack Query (React Query)**
*   **No.3: SWR**

#### なぜそれがNo1なの？
*   Reactの標準機能だけで完結し、追加ライブラリが不要だから。入門書でも最初に教えられる方法。

#### No2の特徴と、No1に劣る点
*   **TanStack Query:** 「サーバー状態管理」という概念を持ち込んだ革命的ライブラリ。キャッシュ、再取得、無限スクロールなどを宣言的に書ける。
*   劣る点: バンドルサイズが少し増える。概念（Stale-While-Revalidate）の理解が必要。

#### No3の特徴と、No1,2に劣る点
*   **SWR:** Vercel製の軽量ライブラリ。No.2と似ているが、機能は少なめ。
*   劣る点: TanStack Queryほどエコシステム（DevToolsなど）が強力ではない。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **TanStack Query** (No.2)

#### 推奨する理由
No.1 (useEffect) は **「手続き的」** すぎて、バグの温床になるからです。「マウント時にfetchして、loadingをtrueにして、エラーなら...」という定型コードを毎回書くのは非生産的です。
今回の「関数型・宣言的」な方針には、**「データ取得の状態（Loading/Error/Success）を宣言的に扱える」** TanStack Queryが最適です。

---

## 論点3：APIクライアント (API Client)

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: Axios / fetch (手書き)**
*   **No.2: Orval (自動生成)**
*   **No.3: OpenAPI Generator (公式)**

#### なぜそれがNo1なの？
*   シンプルで柔軟。API仕様書がなくても始められるから。

#### No2の特徴と、No1に劣る点
*   **Orval:** OpenAPI定義から、TypeScriptの型とTanStack Queryのフックを生成するツール。
*   劣る点: OpenAPI定義ファイル (`openapi.yaml`) が必須。

#### No3の特徴と、No1,2に劣る点
*   **OpenAPI Generator (Java製):** 歴史があるが、生成されるコードが古臭く（Classベースなど）、React Hooksとの相性が悪い。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **Orval** (No.2)

#### 推奨する理由
No.1 (手書き) は **「変更への追従コスト」** が高すぎるからです。Go側でAPIを変えるたびにフロントエンドを手修正するのは時間の無駄です。
Orvalを使えば、**「バックエンドの変更 = コマンド1発でフロントエンドの型定義完了」** という世界に行けます。型安全を突き詰めるなら必須です。

---

## 論点4：状態管理 (State Management)

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: React Context API (標準)**
*   **No.2: Redux (Toolkit)**
*   **No.3: Zustand**

#### なぜそれがNo1なの？
*   標準機能であり、追加インストール不要だから。

#### No2の特徴と、No1に劣る点
*   **Redux:** 厳格なFluxアーキテクチャ。大規模基幹系・業務システムでの採用実績が最も多い。予測可能性・デバッグ（DevTools）・Middlewareで監査ログなどにも対応しやすい。
*   劣る点: ボイラープレート（記述量）が多く、小〜中規模では過剰になりがち。

#### No3の特徴と、No1,2に劣る点
*   **Zustand:** Reduxの単一ストア・不変性の考え方を継ぎつつ、Hooksで最小記述量にしたライブラリ。プロダクション利用の実績あり。
*   劣る点: Reduxほどのエコシステム（Middleware・DevToolsの豊富さ）はない。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **Zustand** (No.3)

#### 推奨する理由
**堅実さ・仕事での転用を踏まえた選定観点**で比較した結果とする。

*   **No.1 (Context)** は、状態更新時に購読コンポーネントがまとめて再レンダリングしやすく、パフォーマンスチューニングが難しい。大規模画面では避けられることが多い。
*   **No.2 (Redux)** は基幹系で最も選ばれやすいが、記述量が多く、個人開発〜中規模ではコストが重い。Reduxの「考え方」（単一ストア・明示的更新・予測可能性）は押さえておく価値がある。
*   **No.3 (Zustand)** は、その考え方を維持しつつ記述量を抑えた「枯れたプロダクション向け」の選択肢。デファクトとまでは言えないが、Reactエコシステム内で広く使われており、個人開発で学んだパターン（ストア設計・スライス分け）はRedux寄りの設計にも転用しやすい。今回の規模では **「堅実さと実装コストのバランス」** でZustandを採用する。

---

## 論点リスト（全件）

- ルーティング (Routing)
- データ取得 (Data Fetching)
- APIクライアント (API Client)
- 状態管理 (State Management)
- エラーハンドリング
- ログ出力・監視
- 共通コンポーネントの粒度

---

## 論点5：エラーハンドリング

### 各論点でのデファクトスタンダードについてのInput

### No1,2,3はどれか？
*   **No.1: 各所で try-catch + ローカル state（error を保持して表示）**
*   **No.2: React Error Boundary（標準・クラスコンポーネントで実装）**
*   **No.3: react-error-boundary（ライブラリ）＋ トースト/スナックバー（通知UI）**

### なぜそれがNo1なの？
*   追加ライブラリ不要で、fetch やイベントハンドラの周りに try-catch を書けばよい。入門書でも最初に出てくる書き方。

### No2の特徴と、No1に劣る点
*   **Error Boundary**：子コンポーネントツリーのレンダリング中に起きたエラーを捕捉し、アプリ全体のクラッシュを防ぐ。React 標準の概念。
*   劣る点：クラスコンポーネントでしか実装できず、イベントハンドラ・非同期（useEffect 内の API エラー）は捕捉できない。

### No3の特徴と、No1,2に劣る点
*   **react-error-boundary**：関数コンポーネント向けの Error Boundary と useErrorBoundary フックを提供。**トースト/スナックバー**（sonner, react-hot-toast 等）はユーザー向けの Information/Warning/Error 通知に使う。
*   劣る点：ライブラリ追加が必要。通知UIは「どこで何を出すか」の設計が必要。

### 各論点での今回採用技術

### 今回採用を推奨するのはどれか？
👉 **No.2（Error Boundary）＋ No.3 の通知UI（例：sonner）を併用**。API エラーは TanStack Query の isError/error で扱う前提。

### 推奨する理由
No.1 だけだと、エラー処理が各所に散らばり、パターンが揃いにくい。**レンダリング中のクラッシュ**は Error Boundary（No.2）で必ず捕捉したい。React 標準で足りるならクラスで1つ書くか、react-error-boundary でラップする。
**ユーザー向けメッセージ**（成功・警告・エラー）は No.3 のトーストを用意しておくと、Information/Warning/Error の出し方を一箇所にまとめられる。shadcn/ui と相性が良い sonner などが候補。No.1 を使わない理由は、try-catch だけでは「どこでどうユーザーに伝えるか」が属人化しやすく、Error Boundary で守るラインと役割が分かれないため。

---

## 論点6：ログ出力・監視

### 各論点でのデファクトスタンダードについてのInput

### No1,2,3はどれか？
*   **No.1: console.log / console.error（そのまま）**
*   **No.2: 構造化ログ用ライブラリ（loglevel, pino 等）でレベル別・環境別出力**
*   **No.3: 本番向けエラー追跡サービス（Sentry, LogRocket, Datadog RUM 等）**

### なぜそれがNo1なの？
*   実装不要で、開発中は console で十分。デバッグの第一歩として誰もが使う。

### No2の特徴と、No1に劣る点
*   **構造化ログ**：ログレベル（debug/info/warn/error）の切り替え、本番では console を抑えるなどの制御がしやすい。
*   劣る点：フロントでは本番でログをどこに送るかが別問題であり、ライブラリを入れても「開発時の見やすさ」が主な利得になりがち。

### No3の特徴と、No1,2に劣る点
*   **Sentry 等**：本番で発生したエラーのスタックトレース・リプレイ・Breadcrumbs を収集。障害調査でよく使われる。
*   劣る点：外部サービス依存、設定とフィルタリング（ノイズ除外）の手間がある。個人開発・小規模では過剰になりうる。

### 各論点での今回採用技術

### 今回採用を推奨するのはどれか？
👉 **No.2（構造化ログ用ライブラリ）を導入し、開発・本番ともに共通のログインターフェースを持つ**

### 推奨する理由
ParallelCalendar は個人開発でありつつも、将来的に業務システムに近い形で運用することを想定しているため、「どのレベルのログをどこで出すか」をコード上で統一しておくことが重要になる。ブラウザ側で完結する範囲では、`console.log` を直接呼ぶのではなく、軽量なログライブラリ（例：`loglevel`）を 1 箇所で初期化し、`logger.debug/info/warn/error` のような共通インターフェース越しに出力する方が、将来「出力先を変える」「本番は warn 以上だけに絞る」といった切り替えがしやすい。外部SaaS（Sentry 等）には依存せず、あくまでフロントエンド内でログレベルと出力形式を統一することを目的とする。

---

## 論点7：共通コンポーネントの粒度

### 各論点でのデファクトスタンダードについてのInput

### No1,2,3はどれか？
*   **No.1: 共通化をほとんどせず、画面ごとにべたに書く**
*   **No.2: 小さな単位（Button, Input, Label 等の atoms）のみ共通化**
*   **No.3: 中〜大単位（FormField, Card, Modal, レイアウト用ブロック等）まで共通化（Atomic Design の molecules/organisms に相当）**

### なぜそれがNo1なの？
*   プロジェクトが小さいうちは重複が少なく、共通化のコストの方が大きいと判断されやすい。とりあえず動かすならこれでよい。

### No2の特徴と、No1に劣る点
*   **atoms のみ共通化**：見た目と振る舞いの最小単位を揃える。shadcn/ui を入れると、このレイヤーはほぼ shadcn に任せられる。
*   劣る点：画面ごとに「フォーム1ブロック」「カード1ブロック」を繰り返し書くことになり、ドメインに近いパターンは共有されない。

### No3の特徴と、No1,2に劣る点
*   **molecules/organisms まで共通化**：複数 atom を組み合わせた「意味のある塊」を共通コンポーネントにする。再利用と一貫性は上がるが、境界の判断（どこまでを共通にするか）が難しい。
*   劣る点：過度に共通化すると props が増え、かえって使いづらくなる。プロジェクト規模に合わせた線引きが必要。

### 各論点での今回採用技術

### 今回採用を推奨するのはどれか？
👉 **No.2（atoms は shadcn に任せる）＋ 機能単位（feature）内で中粒度（カレンダー用ツールバー、フォームブロック等）をまとめる**

### 推奨する理由
UI は shadcn/ui で決まっているため、**atoms 相当は shadcn が担当**する。共通コンポーネントの「粒度」で検討するのは、その上の中〜大単位。Feature-based 構成なら、**各 feature 内に「その機能で繰り返し使う塊」を molecules 的に置く**形がよい。アプリ全体で本当に共通にしたいものだけ shared（または components）に出す。No.1 を使わない理由は、shadcn を入れている時点で最小単位は揃える方針になっており、重複を減らすなら「どの粒度まで共通化するか」を決める必要があるため。No.3 をいきなり全面採用すると設計コストが大きいので、**feature 内で必要な中粒度から始め、共通化した方が得だと判断したものだけ shared に昇格させる**方針とする。

---

## 補足：ParallelCalendar v0.1 における状態管理・エラー・フォームの最終方針

### 状態管理の最終方針

ParallelCalendar v0.1 では、「将来大規模基幹系業務システムでも通用する設計を学ぶ」という観点から、状態の役割を次のように分ける。

- **サーバー状態（Server State）**：TanStack Query で管理する。
	- 対象：カレンダーイベント一覧、カレンダー種別一覧、ログインユーザー情報などバックエンド起源のデータ。
	- 理由：キャッシュ、再取得、エラー・ローディング状態を宣言的に扱え、API 仕様変更にも追従しやすいため。

- **アプリケーション状態（App-level State）**：Redux Toolkit で管理する。
	- 対象：ビュー種別（`month/week/day`）、選択中日付、キーボードショートカットからの遷移状態、画面間で共有する UI 状態など（あくまでイメージ）。
	- 理由：
		- Redux DevTools により「どのアクションからどのように状態が変化したか」を時系列で追跡でき、基幹系で求められる観測性を学べる。
		- `calendarSlice` のように slice 単位で業務ドメインを切り出せるため、業務イベント（例：`calendar/viewChanged`, `calendar/dateMoved`）とコードを対応付けやすい。
		- 仕事で想定される Redux 中心の状態管理パターンに近く、学習効果が高い。

- **ローカル UI 状態（Component Local State）**：React 標準の `useState` / `useReducer` を使う。
	- 対象：ダイアログの一時的な入力値、タブの選択状態など、単一画面・単一コンポーネント内で完結するもの。
	- 理由：スコープが狭い状態はコンポーネント内に閉じることで、Redux の責務を「画面間で共有するべき状態」に集中させる。

---

### エラー分類と UI での扱い

エラーは、ユーザー視点とシステム視点の両方から次のように分類し、UI での扱いを固定する。

- **技術的エラー（Technical Error）**
	- 例：ネットワークエラー、サーバー内部エラー（5xx）、予期しない例外。
	- 取得元：TanStack Query の `error` / `isError`、Error Boundary。
	- UI 方針：
		- 画面右上の Toast（shadcn/ui または sonner）で通知する。
		- 重大な例外は最上位の Error Boundary で捕捉し、「予期しないエラーが発生しました。ページを再読み込みしてください。」のようなメッセージを表示する。
	- 理由：技術的エラーは利用者の操作では防げず、「いつ何が起きたか」を短時間で伝えることが重要。

- **業務エラー（Business Error）**
	- 例：ログイン失敗、フォームのバリデーション NG、業務ルール違反（終了日時が開始日時より前など）。
	- 取得元：バックエンドが返す業務エラーメッセージ、Zod バリデーション結果、ログイン API のレスポンス。
	- UI 方針：
		- React Hook Form + Zod を用いて、フィールド単位またはフォーム単位のエラーメッセージとして画面内に表示する。
		- 重要な確認が必要な操作（例：イベント削除）の場合のみ、shadcn/ui の `AlertDialog` などを併用する。
	- 理由：業務エラーは「次にどう直せばよいか」をユーザーが判断できることが重要であり、Toast よりもフォーム近傍のメッセージの方が行動に結びつきやすい。

ログ出力・監視については、開発時は `console.log` / `console.error` を使いつつ、本番環境では Sentry 等のエラー追跡サービスを必ず有効化し、障害時のスタックトレース・発生頻度・発生画面を追跡できるようにする。

---

## 論点8：フォーム管理

### 各論点でのデファクトスタンダードについてのInput

#### No1,2,3はどれか？

- **No.1：React Hook Form**
- **No.2：TanStack Form**
- **No.3：useActionState（React 標準の Action ベースフォーム）**

#### なぜそれがNo1なの？

- React Hook Form は React 界隈で利用実績が多く、記事・サンプル・Q&A が豊富。
- `@hookform/resolvers/zod` により Zod スキーマとの連携が標準化されており、業務エラー（バリデーション NG）の表現を一箇所に集約しやすい。
- shadcn/ui のフォーム例が React Hook Form 前提で書かれているものが多く、UI をそのまま流用しやすい。
- Redux Toolkit と併用されることも多く、基幹系業務システムでよく見られる「Redux + RHF + サーバ状態管理」のパターンに近い構成を学べる。

#### No2の特徴と、No1との比較

- **TanStack Form**
	- TanStack Router / Query と思想を揃えた宣言的なフォームライブラリであり、フォーム状態を構造化して扱える。
	- 現時点では React Hook Form に比べると利用事例・日本語情報が少なく、shadcn/ui との具体的な組み合わせ例も限られている。
	- 「TanStack 一式で揃える」という学習テーマには適しているが、今回の目的（基幹系寄りのフォーム文化を体験する）からは距離があるため、v0.1 では採用を見送る。

#### No3の特徴と、No1,2との比較

- **useActionState**
	- React 公式が推す Action ベースのフォームパターンであり、特に Next.js App Router + Server Actions との相性が良い。
	- 本プロジェクトは Vite + SPA 構成かつバックエンド別プロセスであり、useActionState の特長である「サーバ側の Action と連動したフォーム設計」を十分に活かしにくい。
	- SPA 側だけでフィールド単位のバリデーションや業務エラー表現を組み立てる場合、結局自前コードが増え、React Hook Form と比べた優位性が小さい。

### 各論点での今回採用技術

#### 今回採用を推奨するのはどれか？

👉 **React Hook Form（No.1）＋ Zod ＋ shadcn/ui のフォームコンポーネント**

#### 推奨する理由

- 評価観点：
	- **エコシステム・情報量**：解説記事・サンプルコード・Q&A が多く、つまづいたときに解決策を見つけやすい。
	- **UI コンポーネントとの親和性**：shadcn/ui が React Hook Form を前提にしたフォーム例を複数公開しており、ParallelCalendar のログイン画面やイベント編集フォームにそのまま転用できる。
	- **業務エラー表現**：Zod スキーマと連携することで、「業務ルール違反をどこで判定し、どこにメッセージを出すか」を一箇所にまとめられる。
	- **仕事での転用性**：Redux Toolkit と組み合わせる構成が企業プロダクトでも一般的であり、基幹系業務システムのフォーム実装パターンを学びやすい。
- これらの理由から、ParallelCalendar v0.1 では **React Hook Form をフォーム管理の標準**とし、TanStack Form・useActionState は将来的な検証候補に留める。

---

### 補足：v0.1 の認証・権限スコープ

- 認証はベーシック認証のみとし、フロントエンド側では「認証済みかどうか」の判定と 401 エラー時の再認証要求に限定して扱う。
- 権限は全ユーザー同一とし、画面表示や操作可否をロールベースで切り替える処理は実装しない。
- 将来的に Google 認証などを導入する際は、ログイン画面の UI（shadcn/ui の Authentication レイアウト）をベースにボタンやフローを拡張する。

---

### 補足：v0.1 のテスト戦略

- v0.1 の開発フェーズでは、自動テスト（Unit / Integration / E2E）は必須要件とせず、**手動動作確認**を中心とする。
- 手動確認の重点シナリオ：
	- ログインからカレンダー画面表示までの一連の流れ。
	- カレンダーの表示切替（`month/week/day`）、日付移動、ドラッグ＆ドロップによるイベント日時変更。
	- イベントの新規作成・編集・削除と、その結果の画面反映。
- 将来、最低限のテストコード（Redux slice のロジック、フォームのバリデーション、主要なカレンダー操作の E2E など）を追加する段階で、テスト戦略を再検討し RePlan する。