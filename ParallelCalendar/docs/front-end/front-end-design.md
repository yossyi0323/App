# Front-end Design

## 技術スタック

### 使用決定しているツールやライブラリ
- react-big-calendar
- Vite
- React
- TypeScript
- TailwindCSS
- shadcn/ui
- Vitest
- ベーシック認証（とりあえず最低限）、できればGoogle認証
- ESLint
- Prettier
- Zod
- OpenAPI
- TanStack Query
- Orval
- date-fns

ディレクトリ構成：レイヤーベース成にする。

### 検討中の論点や、使用する可能性のあるツールやライブラリ

1. Information、Warning、Errorのメッセージの出し方？
2. 画面レイアウト？
3. ルーティング？
4. Orval
5. TanStack Query
6. 認可？
7. Client State (UIの状態) をどう扱うか？
    - A案: Context API (React標準)
    - B案: Zustand (軽量・簡単)
    - C案: Redux (重厚・実績あり)

Playwright？←E2Eは今のフェーズではまだ不要。
- **Client**: react-big-calendar, Vite, React, TypeScript, TailwindCSS
- **UI**: shadcn/ui
- **Test**: Vitest
- **Auth**: ベーシック認証（将来的にOneLogin/Google認証）
- **Linter**: ESLint, Prettier
- **Schema**: Zod
- **API Spec**: OpenAPI

---

## 論点リスト

1.  ルーティング (Routing)
2.  データ取得 (Data Fetching)
3.  APIクライアント (API Client)
4.  状態管理 (State Management)
5.  エラーハンドリング
6.  ログ出力・監視
7.  共通コンポーネントの粒度


---

## 論点1：ルーティング

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: React Router (v6/v7)**
*   **No.2: Next.js (App Router) Built-in**
*   **No.3: TanStack Router**

#### なぜそれがNo1なの？
*   React初期から存在し、圧倒的なドキュメント量とコミュニティがあるため。「迷ったらこれ」という安心感がある。

#### No2の特徴と、No1に劣る点
*   **Next.js Built-in:** Next.jsを使うならこれ一択だが、React単体では使えない。
*   劣る点: フレームワーク（Next.js）にロックインされる。

#### No3の特徴と、No1,2に劣る点
*   **TanStack Router:** 「型安全性 (Type-Safety)」を最優先に設計された新世代ルーター。URLパラメータの変更にコンパイラが気づける。
*   劣る点: 学習コストが少し高い。概念が新しい（ファイルベースルーティングなど）。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **TanStack Router** (No.3)

#### 推奨する理由
あえてNo.1を選ばない理由は、**「URL変更に伴うバグを撲滅したいから」** です。
カレンダーアプリでは `/calendar?view=month&date=2026-02` のようにURLパラメータを多用します。React Router (No.1) はここが弱く、パラメータ名を変えてもエラーが出ず、実行時に動かなくなります。
TanStack Routerなら、コードを書いている最中に赤線が出るため、堅牢性が段違いです。

---

## 論点2：データ取得 (Data Fetching)

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: useEffect + fetch (標準)**
*   **No.2: TanStack Query (React Query)**
*   **No.3: SWR**

#### なぜそれがNo1なの？
*   Reactの標準機能だけで完結し、追加ライブラリが不要だから。入門書でも最初に教えられる方法。

#### No2の特徴と、No1に劣る点
*   **TanStack Query:** 「サーバー状態管理」という概念を持ち込んだ革命的ライブラリ。キャッシュ、再取得、無限スクロールなどを宣言的に書ける。
*   劣る点: バンドルサイズが少し増える。概念（Stale-While-Revalidate）の理解が必要。

#### No3の特徴と、No1,2に劣る点
*   **SWR:** Vercel製の軽量ライブラリ。No.2と似ているが、機能は少なめ。
*   劣る点: TanStack Queryほどエコシステム（DevToolsなど）が強力ではない。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **TanStack Query** (No.2)

#### 推奨する理由
No.1 (useEffect) は **「手続き的」** すぎて、バグの温床になるからです。「マウント時にfetchして、loadingをtrueにして、エラーなら...」という定型コードを毎回書くのは非生産的です。
今回の「関数型・宣言的」な方針には、**「データ取得の状態（Loading/Error/Success）を宣言的に扱える」** TanStack Queryが最適です。

---

## 論点3：APIクライアント (API Client)

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: Axios / fetch (手書き)**
*   **No.2: Orval (自動生成)**
*   **No.3: OpenAPI Generator (公式)**

#### なぜそれがNo1なの？
*   シンプルで柔軟。API仕様書がなくても始められるから。

#### No2の特徴と、No1に劣る点
*   **Orval:** OpenAPI定義から、TypeScriptの型とTanStack Queryのフックを生成するツール。
*   劣る点: OpenAPI定義ファイル (`openapi.yaml`) が必須。

#### No3の特徴と、No1,2に劣る点
*   **OpenAPI Generator (Java製):** 歴史があるが、生成されるコードが古臭く（Classベースなど）、React Hooksとの相性が悪い。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **Orval** (No.2)

#### 推奨する理由
No.1 (手書き) は **「変更への追従コスト」** が高すぎるからです。Go側でAPIを変えるたびにフロントエンドを手修正するのは時間の無駄です。
Orvalを使えば、**「バックエンドの変更 = コマンド1発でフロントエンドの型定義完了」** という世界に行けます。型安全を突き詰めるなら必須です。

---

## 論点4：状態管理 (State Management)

### 各論点でのデファクトスタンダードについてのInput
#### No1,2,3はどれか？
*   **No.1: React Context API (標準)**
*   **No.2: Redux (Toolkit)**
*   **No.3: Zustand**

#### なぜそれがNo1なの？
*   標準機能であり、追加インストール不要だから。

#### No2の特徴と、No1に劣る点
*   **Redux:** 厳格なFluxアーキテクチャ。大規模基幹系・業務システムでの採用実績が最も多い。予測可能性・デバッグ（DevTools）・Middlewareで監査ログなどにも対応しやすい。
*   劣る点: ボイラープレート（記述量）が多く、小〜中規模では過剰になりがち。

#### No3の特徴と、No1,2に劣る点
*   **Zustand:** Reduxの単一ストア・不変性の考え方を継ぎつつ、Hooksで最小記述量にしたライブラリ。プロダクション利用の実績あり。
*   劣る点: Reduxほどのエコシステム（Middleware・DevToolsの豊富さ）はない。

### 各論点での今回採用技術
#### 今回採用を推奨するのはどれか？
👉 **Zustand** (No.3)

#### 推奨する理由
**堅実さ・仕事での転用を踏まえた選定観点**で比較した結果とする。

*   **No.1 (Context)** は、状態更新時に購読コンポーネントがまとめて再レンダリングしやすく、パフォーマンスチューニングが難しい。大規模画面では避けられることが多い。
*   **No.2 (Redux)** は基幹系で最も選ばれやすいが、記述量が多く、個人開発〜中規模ではコストが重い。Reduxの「考え方」（単一ストア・明示的更新・予測可能性）は押さえておく価値がある。
*   **No.3 (Zustand)** は、その考え方を維持しつつ記述量を抑えた「枯れたプロダクション向け」の選択肢。デファクトとまでは言えないが、Reactエコシステム内で広く使われており、個人開発で学んだパターン（ストア設計・スライス分け）はRedux寄りの設計にも転用しやすい。今回の規模では **「堅実さと実装コストのバランス」** でZustandを採用する。

---

## 論点リスト（全件）

- ルーティング (Routing)
- データ取得 (Data Fetching)
- APIクライアント (API Client)
- 状態管理 (State Management)
- エラーハンドリング
- ログ出力・監視
- 共通コンポーネントの粒度

---

## 論点5：エラーハンドリング

### 各論点でのデファクトスタンダードについてのInput

### No1,2,3はどれか？
*   **No.1: 各所で try-catch + ローカル state（error を保持して表示）**
*   **No.2: React Error Boundary（標準・クラスコンポーネントで実装）**
*   **No.3: react-error-boundary（ライブラリ）＋ トースト/スナックバー（通知UI）**

### なぜそれがNo1なの？
*   追加ライブラリ不要で、fetch やイベントハンドラの周りに try-catch を書けばよい。入門書でも最初に出てくる書き方。

### No2の特徴と、No1に劣る点
*   **Error Boundary**：子コンポーネントツリーのレンダリング中に起きたエラーを捕捉し、アプリ全体のクラッシュを防ぐ。React 標準の概念。
*   劣る点：クラスコンポーネントでしか実装できず、イベントハンドラ・非同期（useEffect 内の API エラー）は捕捉できない。

### No3の特徴と、No1,2に劣る点
*   **react-error-boundary**：関数コンポーネント向けの Error Boundary と useErrorBoundary フックを提供。**トースト/スナックバー**（sonner, react-hot-toast 等）はユーザー向けの Information/Warning/Error 通知に使う。
*   劣る点：ライブラリ追加が必要。通知UIは「どこで何を出すか」の設計が必要。

### 各論点での今回採用技術

### 今回採用を推奨するのはどれか？
👉 **No.2（Error Boundary）＋ No.3 の通知UI（例：sonner）を併用**。API エラーは TanStack Query の isError/error で扱う前提。

### 推奨する理由
No.1 だけだと、エラー処理が各所に散らばり、パターンが揃いにくい。**レンダリング中のクラッシュ**は Error Boundary（No.2）で必ず捕捉したい。React 標準で足りるならクラスで1つ書くか、react-error-boundary でラップする。
**ユーザー向けメッセージ**（成功・警告・エラー）は No.3 のトーストを用意しておくと、Information/Warning/Error の出し方を一箇所にまとめられる。shadcn/ui と相性が良い sonner などが候補。No.1 を使わない理由は、try-catch だけでは「どこでどうユーザーに伝えるか」が属人化しやすく、Error Boundary で守るラインと役割が分かれないため。

---

## 論点6：ログ出力・監視

### 各論点でのデファクトスタンダードについてのInput

### No1,2,3はどれか？
*   **No.1: console.log / console.error（そのまま）**
*   **No.2: 構造化ログ用ライブラリ（loglevel, pino 等）でレベル別・環境別出力**
*   **No.3: 本番向けエラー追跡サービス（Sentry, LogRocket, Datadog RUM 等）**

### なぜそれがNo1なの？
*   実装不要で、開発中は console で十分。デバッグの第一歩として誰もが使う。

### No2の特徴と、No1に劣る点
*   **構造化ログ**：ログレベル（debug/info/warn/error）の切り替え、本番では console を抑えるなどの制御がしやすい。
*   劣る点：フロントでは本番でログをどこに送るかが別問題であり、ライブラリを入れても「開発時の見やすさ」が主な利得になりがち。

### No3の特徴と、No1,2に劣る点
*   **Sentry 等**：本番で発生したエラーのスタックトレース・リプレイ・Breadcrumbs を収集。障害調査でよく使われる。
*   劣る点：外部サービス依存、設定とフィルタリング（ノイズ除外）の手間がある。個人開発・小規模では過剰になりうる。

### 各論点での今回採用技術

### 今回採用を推奨するのはどれか？
👉 **No.1（console）を基本とし、本番監視が必要になったら No.3（Sentry 等）を検討**

### 推奨する理由
現フェーズでは開発時の確認が主目的なら No.1 で足りる。Orval と TanStack Query で API は型安全に扱えるため、まずは「どこで何が起きたか」を console で追えるようにしておけばよい。No.2 は「レベル切り替えや共通フォーマットが欲しくなったら」でよい。No.3 は、本番公開後にエラー収集・障害調査をしたくなった段階で導入する選択肢。No.1 を使わないのではなく、**まず No.1 で始め、必要に応じて No.3 を足す**という段階的な選び方にする。

---

## 論点7：共通コンポーネントの粒度

### 各論点でのデファクトスタンダードについてのInput

### No1,2,3はどれか？
*   **No.1: 共通化をほとんどせず、画面ごとにべたに書く**
*   **No.2: 小さな単位（Button, Input, Label 等の atoms）のみ共通化**
*   **No.3: 中〜大単位（FormField, Card, Modal, レイアウト用ブロック等）まで共通化（Atomic Design の molecules/organisms に相当）**

### なぜそれがNo1なの？
*   プロジェクトが小さいうちは重複が少なく、共通化のコストの方が大きいと判断されやすい。とりあえず動かすならこれでよい。

### No2の特徴と、No1に劣る点
*   **atoms のみ共通化**：見た目と振る舞いの最小単位を揃える。shadcn/ui を入れると、このレイヤーはほぼ shadcn に任せられる。
*   劣る点：画面ごとに「フォーム1ブロック」「カード1ブロック」を繰り返し書くことになり、ドメインに近いパターンは共有されない。

### No3の特徴と、No1,2に劣る点
*   **molecules/organisms まで共通化**：複数 atom を組み合わせた「意味のある塊」を共通コンポーネントにする。再利用と一貫性は上がるが、境界の判断（どこまでを共通にするか）が難しい。
*   劣る点：過度に共通化すると props が増え、かえって使いづらくなる。プロジェクト規模に合わせた線引きが必要。

### 各論点での今回採用技術

### 今回採用を推奨するのはどれか？
👉 **No.2（atoms は shadcn に任せる）＋ 機能単位（feature）内で中粒度（カレンダー用ツールバー、フォームブロック等）をまとめる**

### 推奨する理由
UI は shadcn/ui で決まっているため、**atoms 相当は shadcn が担当**する。共通コンポーネントの「粒度」で検討するのは、その上の中〜大単位。Feature-based 構成なら、**各 feature 内に「その機能で繰り返し使う塊」を molecules 的に置く**形がよい。アプリ全体で本当に共通にしたいものだけ shared（または components）に出す。No.1 を使わない理由は、shadcn を入れている時点で最小単位は揃える方針になっており、重複を減らすなら「どの粒度まで共通化するか」を決める必要があるため。No.3 をいきなり全面採用すると設計コストが大きいので、**feature 内で必要な中粒度から始め、共通化した方が得だと判断したものだけ shared に昇格させる**方針とする。

---